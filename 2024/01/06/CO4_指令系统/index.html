<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>指令系统 | CO | ZERO</title><meta name="keywords" content="计算机组成原理"><meta name="author" content="zero"><meta name="copyright" content="zero"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="指令系统   指令（机器指令） 指示计算机执行某种操作的命令 是计算机运行的最小功能单位   指令集体系结构 ISA ISA 完整定义了软件和硬件之间的接口 ISA 规定的内容主要包括：指令格式，数据类型及格式，操作数的存放方式，程序可访问的寄存器个数、位数和编号，存储空间的大小和编址方式，寻址方式，指令执行过程的控制方式等   指令系统（指令集） 一台计算机的所有指令的集合 是计算机硬件的语言">
<meta property="og:type" content="article">
<meta property="og:title" content="指令系统 | CO">
<meta property="og:url" content="https://zerooo.top/2024/01/06/CO4_%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="ZERO">
<meta property="og:description" content="指令系统   指令（机器指令） 指示计算机执行某种操作的命令 是计算机运行的最小功能单位   指令集体系结构 ISA ISA 完整定义了软件和硬件之间的接口 ISA 规定的内容主要包括：指令格式，数据类型及格式，操作数的存放方式，程序可访问的寄存器个数、位数和编号，存储空间的大小和编址方式，寻址方式，指令执行过程的控制方式等   指令系统（指令集） 一台计算机的所有指令的集合 是计算机硬件的语言">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg">
<meta property="article:published_time" content="2024-01-06T01:36:57.000Z">
<meta property="article:modified_time" content="2024-01-09T12:59:40.998Z">
<meta property="article:author" content="zero">
<meta property="article:tag" content="计算机组成原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg"><link rel="shortcut icon" href="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/favicon.png"><link rel="canonical" href="https://zerooo.top/2024/01/06/CO4_%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '指令系统 | CO',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-09 20:59:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/catalog.css?1"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZERO</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">指令系统 | CO</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-06T01:36:57.000Z" title="发表于 2024-01-06 09:36:57">2024-01-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-09T12:59:40.998Z" title="更新于 2024-01-09 20:59:40">2024-01-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%80%83%E7%A0%94408/">考研408</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="指令系统 | CO"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="指令系统"><a class="markdownIt-Anchor" href="#指令系统"></a> 指令系统</h2>
<ul>
<li>
<p>指令（机器指令）</p>
<p>指示计算机执行某种操作的命令</p>
<p>是计算机运行的最小功能单位</p>
</li>
<li>
<p>指令集体系结构 ISA</p>
<p>ISA 完整定义了软件和硬件之间的接口</p>
<p>ISA 规定的内容主要包括：指令格式，数据类型及格式，操作数的存放方式，程序可访问的寄存器个数、位数和编号，存储空间的大小和编址方式，寻址方式，指令执行过程的控制方式等</p>
</li>
<li>
<p>指令系统（指令集）</p>
<p>一台计算机的所有指令的集合</p>
<p>是计算机硬件的语言系统</p>
<p>位于硬件和软件的交界面上</p>
<p>是计算机的主要属性，是表征一台计算机性能的重要因素</p>
<p>它的格式与功能不仅直接影响到机器的硬件结构，而且也直接影响到系统软件，影响到机器的适用范围</p>
<p>指令系统是指令集体系结构中最核心的部分</p>
</li>
<li>
<p>引入指令系统的目的</p>
<p>避免用户与二进制代码直接接触，使得用户编写程序更为方便</p>
</li>
</ul>
<h3 id="指令的基本格式"><a class="markdownIt-Anchor" href="#指令的基本格式"></a> 指令的基本格式</h3>
<ul>
<li>
<p>一条指令通常包括：操作码字段(OP) + 地址码字段(A)</p>
<ol>
<li>
<p>操作码</p>
<p>指出该指令应执行什么性质的操作以及具有何种功能</p>
<p>是识别指令、了解指令功能及区分操作数地址内容的组成和使用方法等的关键信息</p>
</li>
<li>
<p>地址码</p>
<p>给出被操作信息（指令或数据）的地址</p>
<p>包括：参与运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用的子程序的入口地址等</p>
<p>一条指令可能包含 0、1、2、3、4 个地址码</p>
</li>
</ol>
</li>
<li>
<p>“字长”</p>
<ol>
<li>
<p>机器字长</p>
<p>计算机进行一次整数运算（即定点整数运算）所能处理的二进制数据的位数</p>
<p>与 CPU 的寄存器位数、加法器有关，一般等于内部寄存器的大小（CPU 内部数据通路宽度），通常选定为字节的整数倍</p>
<p>决定计算机的运算精度：字长越长，数的表示范围越大、计算精度越高</p>
<p>ALU 和通用寄存器位数（宽度）一定与机器字长相同</p>
</li>
<li>
<p>存储字长</p>
<p>一个存储单元中的二进制代码的位数，等于 MDR 的位数</p>
</li>
<li>
<p>数据字长</p>
<p>数据总线一次能并行传送信息的位数（外部数据通路宽度），可不等于 MDR 位数</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 位 CPU 中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 就是指数据总线线数，即数据字长</p>
</li>
<li>
<p>指令字长</p>
<p>一个指令字中包含的二进制代码的位数</p>
<p>取决于操作码的长度、操作数地址码的长度和操作数地址的个数</p>
<p>因为主存一般按字节编址，所以指令字长多为字节的整数倍</p>
<p>指令长度与机器字长没有必然关系</p>
<p>单字长指令：指令长度等于机器字长的指令（以此类推：半字长指令、双字长指令）</p>
<p>一般取存储字长的整数倍</p>
</li>
<li>
<p>word</p>
<p>由于 32 或 64 位体系结构都是由 16 位扩展而来，因此用 word 表示 16 位</p>
</li>
</ol>
<blockquote>
<p>“按字寻址”：这里的“字”，有时指机器字长（王道 P150 10），有时指数据字长（王道 P160 14）</p>
</blockquote>
</li>
<li>
<p>定长指令字结构</p>
<p>一个指令系统中所有指令的长度都是相等的</p>
<p>定字长指令的执行速度快，控制简单</p>
</li>
<li>
<p>变长指令字结构</p>
<p>一个指令系统中各种指令的长度随指令功能而异</p>
</li>
<li>
<p>定长操作码</p>
<p>指令系统中所有指令的操作码长度都相同</p>
<p>定长操作码指令在指令字的最高位部分分配固定的若干位（定长）表示操作码</p>
<p>一般 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 位操作码字段的指令系统最大能够表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 条指令</p>
<p>控制器的译码电路设计简单，有利于简化计算机硬件设计、提高指令译码和识别速度，但灵活性较低</p>
<p>当计算机字长为 32 位或更长时，这是常规用法</p>
</li>
<li>
<p>可变长操作码</p>
<p>指令系统中各指令的操作码长度可变，且分散地放在指令字的不同位置上</p>
<p>增加了指令译码和分析的难度，使控制器的译码电路设计复杂，但灵活性较高，在指令字长有限的前提下仍保持比较丰富的指令种类</p>
<p>最常见的变长操作码方法是<strong>扩展操作码</strong>：定长指令字结构 + 可变长操作码</p>
</li>
</ul>
<hr />
<p>根据指令中操作数地址码的数目不同，可将指令分为以下几种格式：</p>
<h4 id="零地址指令"><a class="markdownIt-Anchor" href="#零地址指令"></a> 零地址指令</h4>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3331_1.png" width="80px"/></dev>
<ol>
<li>
<p>不需要操作数的指令，如空操作、停机、关中断等</p>
</li>
<li>
<p>堆栈计算机中的零地址运算类指令，两个操作数隐含存放在栈顶和次栈顶，弹出送到运算器进行运算，运算结果再隐式压回栈顶</p>
<p>堆栈指令的访存次数取决于采用的是软堆栈（由内存实现）还是硬堆栈（由寄存器实现）</p>
<p>软堆栈：对于双目运算需要访存 4 次（取指 → 取 2 个操作数 → 存结果）</p>
<p>硬堆栈：只需在取指时访存 1 次</p>
</li>
</ol>
<h4 id="一地址指令"><a class="markdownIt-Anchor" href="#一地址指令"></a> 一地址指令</h4>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3333_1.png" width="400px"/></dev>
<ol>
<li>
<p>只需要单操作数，如加 1、减 1、取反、求补等</p>
<p>指令含义：OP(A1) → A1</p>
<p>完成一条指令需要 3 次访存：取指 → 读 A1 → 写 A1</p>
</li>
<li>
<p>需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在 ACC）</p>
<p>指令含义： (ACC)OP(A1) → ACC（隐含约定的目的地址为 ACC）</p>
<p>完成一条指令需要 2 次访存：取指 → 读 A1</p>
</li>
</ol>
<h4 id="二地址指令"><a class="markdownIt-Anchor" href="#二地址指令"></a> 二地址指令</h4>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3335_1.png" width="400px"/></dev>
<p>对于常用的算术和逻辑运算指令，往往要求使用两个操作数，需分别给出目的操作数和源操作数的地址，其中目的操作数地址还用于保存本次的运算结果</p>
<p>指令含义：(A1)OP(A2) → A1</p>
<p>完成一条指令需要访存 4 次：取指 → 读 A1 + 读 A2 → 写 A1</p>
<h4 id="三地址指令"><a class="markdownIt-Anchor" href="#三地址指令"></a> 三地址指令</h4>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3337_1.png" width="400px"/></dev>
<p>常用于需要两个操作数的算术运算、逻辑运算相关指令</p>
<p>指令含义：(A1)OP(A2) → A3</p>
<p>完成一条指令需要访存 4 次：取指 → 读 A1 + 读 A2 → 写 A3</p>
<h4 id="四地址指令"><a class="markdownIt-Anchor" href="#四地址指令"></a> 四地址指令</h4>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3339_1.png" width="400px"/></dev>
<p>指令含义：(A1)OP(A2) → A3，A4 = 下一条将要执行指令的地址</p>
<p>完成一条指令需要访存 4 次：取指 → 读 A1 + 读 A2 → 写 A3</p>
<h3 id="扩展操作码指令格式"><a class="markdownIt-Anchor" href="#扩展操作码指令格式"></a> 扩展操作码指令格式</h3>
<ul>
<li>
<p>目的</p>
<p>保持指令字长度不变而增加指令的数量</p>
</li>
<li>
<p>扩展操作码是最常见的变长操作码方法（定长指令字结构 + 可变长操作码）</p>
<p>使操作码的长度随地址码的减少而增加，不同地址数的指令可具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长</p>
</li>
<li>
<p>设计扩展操作码指令格式时，必须注意：</p>
<ol>
<li>各指令的操作码一定不能重复</li>
<li>不允许短码是长码的前缀</li>
</ol>
<p>通常情况下，对使用频率较高的指令，分配较短的操作码；对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间</p>
</li>
<li>
<p>扩展操作码例一</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230721214738217.png" width="500px"/></dev>
</li>
<li>
<p>扩展操作码例二</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3357_1.png" width="800px"/></dev>
<p>设单个地址码长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>，上一层留出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 种状态，下一层可扩展出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">m × 2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 种状态</p>
</li>
</ul>
<h3 id="指令的操作类型"><a class="markdownIt-Anchor" href="#指令的操作类型"></a> 指令的操作类型</h3>
<h4 id="数据传送"><a class="markdownIt-Anchor" href="#数据传送"></a> 数据传送</h4>
<p>LOAD：从内存单元读取数据到 CPU 寄存器</p>
<p>STORE：从 CPU 寄存器写数据到内存单元</p>
<p>MOV：寄存器之间的传送</p>
<p>……</p>
<h4 id="算术和逻辑运算"><a class="markdownIt-Anchor" href="#算术和逻辑运算"></a> 算术和逻辑运算</h4>
<p>算术：加(ADD)、减(SUB)、乘(MUL)、除(DIV)、增 1(INC)、减 1(DEC)、求补、浮点运算、十进制运算等</p>
<p>逻辑：与(AND)、或(OR)、非(NOT)、异或(XOR)、位操作、位测试、位清除、位求反等</p>
<h4 id="移位操作"><a class="markdownIt-Anchor" href="#移位操作"></a> 移位操作</h4>
<p>算术移位、逻辑移位、循环移位等</p>
<h4 id="转移操作"><a class="markdownIt-Anchor" href="#转移操作"></a> 转移操作</h4>
<p>无条件转移(JMP)、条件转移(BRANCH)、调用(CALL)、返回(RET)、陷阱(TRAP)等</p>
<blockquote>
<p>调用指令 vs 转移指令：执行调用指令时必须保存下一条指令的地址（返回地址），当子程序执行结束时，根据返回地址返回到主程序继续执行；而转移指令则不返回执行</p>
</blockquote>
<h4 id="输入输出操作"><a class="markdownIt-Anchor" href="#输入输出操作"></a> 输入输出操作</h4>
<p>用于完成 CPU 与 I/O 端口（外部设备）交换数据或传送控制命令及状态信息</p>
<hr />
<p>数据传送类指令（数据传送）</p>
<p>运算类指令（算术和逻辑运算、移位操作）</p>
<p>程序控制类指令（转移操作）：改变程序执行的顺序，并使程序具有测试、分析、判断和循环执行的能力</p>
<p>输入输出类指令（输入输出操作）：进行 CPU 和 I/O 设备之间的数据传送</p>
<h2 id="指令的寻址方式"><a class="markdownIt-Anchor" href="#指令的寻址方式"></a> 指令的寻址方式</h2>
<ul>
<li>
<p>寻“址”</p>
<p>寻找指令或操作数的有效地址</p>
<p>即确定本条指令的数据地址及下一条将要执行的指令的地址</p>
</li>
<li>
<p>形式地址 A</p>
<p>指令中的地址字段，不代表操作数的真实地址</p>
<p>符号 (A) 表示 <u>位于 A 地址的数值</u>（A 既可以是寄存器的标号，也可以是内存地址）</p>
</li>
<li>
<p>有效地址 EA (Effective Address)</p>
<p>用形式地址结合寻址方式可计算出操作数在存储系统中的真实地址</p>
<p>EA = (A) 表示 <u>有效地址 = 位于 A 地址的数值</u></p>
<blockquote>
<p>很多资料上都说有效地址只是段内偏移，加上段基址才得到线性地址 LA，若采用了分页机制，LA 还需要进一步转换才能得到物理地址<br />
王道书和考题貌似都默认有效地址等于物理地址<br />
咸鱼说有效地址是虚拟地址！</p>
</blockquote>
</li>
<li>
<p>寻址方式分类</p>
<ol>
<li>
<p>指令寻址</p>
<p>寻找下一条要执行的指令的地址（始终由 PC 给出）</p>
</li>
<li>
<p>数据寻址</p>
<p>寻找操作数的地址（把操作数的形式地址转换成操作数的有效地址的过程）</p>
<p>如何在指令中表示一个操作数的地址、如何用这种表示得到操作数或怎样计算出操作数的地址</p>
<p>指令格式：</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3373_1.png" width="480px"/></dev>
<p>为区别各种方式，通常在指令中设一个字段，用来指明属于哪种寻址方式</p>
</li>
</ol>
</li>
<li>
<p>操作数通常位于：</p>
<ol>
<li>指令代码</li>
<li>CPU 内部的寄存器</li>
<li>主存</li>
<li>I/O 端口</li>
</ol>
</li>
<li>
<p>指令系统中采用不同寻址方式的目的</p>
<p>缩短指令字长，扩大寻址空间，提高编程的灵活性</p>
<blockquote>
<p>但这也提高了指令译码的难度，多重寻址方式会造成 CPU 结构的复杂化，也不利于指令流水线的运行。而寻址方式少虽然能够提高 CPU 的效率，但对于用户而言会使编程变得复杂，很难满足需求</p>
</blockquote>
</li>
</ul>
<h3 id="指令寻址"><a class="markdownIt-Anchor" href="#指令寻址"></a> 指令寻址</h3>
<h4 id="顺序寻址"><a class="markdownIt-Anchor" href="#顺序寻址"></a> 顺序寻址</h4>
<p>程序的指令序列在主存中顺序存放，程序执行时从第一条指令开始，逐条取出并逐条执行</p>
<p>依靠程序计数器 PC 实现</p>
<p>(PC) + “1” → PC。这里的 1 理解为 1 个指令字长，实际加的值会因指令长度、编址方式而不同。取指后一定会 PC + “1”</p>
<h4 id="跳跃寻址"><a class="markdownIt-Anchor" href="#跳跃寻址"></a> 跳跃寻址</h4>
<p>下一条指令的地址不是由 PC 的当前值所给出，而由本条指令给出下条指令地址的计算方式</p>
<p>通过转移类指令实现</p>
<p>是否跳跃可能受到状态寄存器和操作数的控制</p>
<p>跳跃的地址分为绝对地址（由标记符直接得到）和相对地址（相对于当前指令地址的偏移量）</p>
<p>跳跃的处理方式是重新修改 PC 的值（已经 + “1”）后再进入取指阶段（故实际上下一条指令的地址仍是从 PC 获取）</p>
<h3 id="数据寻址"><a class="markdownIt-Anchor" href="#数据寻址"></a> 数据寻址</h3>
<p>采用不同寻址方式的目的是为了缩短指令字长，扩大寻址空间，提高编程的灵活性，但这也提高了指令译码的复杂度</p>
<h4 id="隐含寻址"><a class="markdownIt-Anchor" href="#隐含寻址"></a> 隐含寻址</h4>
<p>指令不显式给出操作数的地址，而在指令中隐含操作数的地址</p>
<p>如单地址指令，规定累加器 ACC 作为第二操作数地址</p>
<p>优点：有利于缩短指令字长，可简化地址结构，是<strong>获取操作数最快的方式</strong></p>
<p>缺点：需要增加存储操作数或隐含地址的硬件</p>
<h4 id="立即数寻址"><a class="markdownIt-Anchor" href="#立即数寻址"></a> 立即（数）寻址</h4>
<p>地址字段即是操作数本身，又称立即数</p>
<p>数据采用补码的方式存放</p>
<p>优点：取出指令即可同时获得操作数，不必再次访存，提高了指令的执行速度，<strong>指令执行时间最短</strong></p>
<p>缺点：对于定长指令格式，A 的位数限制了立即数的取值范围；操作数作为指令的一部分，不能被修改</p>
<p>通常用于给某一寄存器或者主存单元赋值</p>
<h4 id="直接寻址"><a class="markdownIt-Anchor" href="#直接寻址"></a> 直接寻址</h4>
<p>形式地址 A 就是操作数的有效地址 EA，即 EA = A</p>
<p>优点：寻找操作数比较简单，无需专门计算操作数地址，执行阶段只访存一次；相对于立即寻址，缩短了指令长度</p>
<p>缺点：A 的位数限制了操作数的寻址范围，并且操作数的地址不易被修改</p>
<p>在早期的计算机中常常作为主要的寻址方式</p>
<h4 id="间接寻址"><a class="markdownIt-Anchor" href="#间接寻址"></a> 间接寻址</h4>
<p>形式地址 A 指出操作数有效地址 EA 所在的存储单元的地址，即 EA = (A)，有效地址由形式地址间接提供</p>
<p>可以是一次间接寻址，也可以是多次间接寻址：</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3375_1.png" width="600px"/></dev>
<p>主存字第一位为 1 时，表示取出的仍不是操作数的地址，即多次间址；主存字第一位为 0 时，表示取得的是操作数的地址</p>
<p>优点：</p>
<ol>
<li>扩大了操作数的寻址范围（EA 的位数大于 A 的位数）</li>
<li>便于编程，可方便地完成子程序返回：调用子程序前，将返回地址存入子程序最末条指令的形式地址的存储单元，便可准确返回原程序</li>
</ol>
<p>缺点：指令在执行阶段需要多次访存（一次间接寻址就需要两次访存。多次间接寻址需根据存储字的最高位确定访存次数），指令执行时间变长</p>
<h4 id="寄存器寻址"><a class="markdownIt-Anchor" href="#寄存器寻址"></a> 寄存器寻址</h4>
<p>操作数不在内存中，而是放在寄存器中</p>
<p>寄存器寻址在指令中直接给出操作数所在的寄存器编号</p>
<p>形式地址 A 表示的是寄存器的编号 R，即 EA = R</p>
<p>优点：</p>
<ol>
<li>指令在执行阶段不访存，只访问寄存器</li>
<li>因寄存器编号较短（寄存器数量较少），对应地址码长度较小，故可压缩指令字，节省存储空间</li>
<li>支持向量/矩阵运算</li>
<li>执行速度较快：指令字短且不用访存</li>
</ol>
<p>缺点：寄存器价格昂贵，且计算机内寄存器数量有限</p>
<h4 id="寄存器间接寻址"><a class="markdownIt-Anchor" href="#寄存器间接寻址"></a> 寄存器间接寻址</h4>
<p>形式地址 A 所表示的寄存器中，存放的是操作数在内存中的地址，即 EA = ®</p>
<p>需访存，不过相比于间接寻址，减少了一次访存，故比一般间接寻址相比速度更快</p>
<p>一般用于<strong>扩大寻址范围</strong>（提到扩大寻址范围时，通常指的是寄存器间接寻址）</p>
<h4 id="偏移寻址"><a class="markdownIt-Anchor" href="#偏移寻址"></a> 偏移寻址</h4>
<p>直接寻址 + 寄存器间接寻址，即 EA = ® + A</p>
<p>一般有两个地址字段：A—内存形式地址，直接使用；R—某寄存器编号，间接使用</p>
<p>根据使用的寄存器是专用还是通用寄存器，可分为隐式偏移（使用专门的寄存器，不需在指令中指明寄存器编号）和显式偏移</p>
<p>常用的三种形式：相对寻址、基址寻址、变址寻址</p>
<h5 id="相对寻址"><a class="markdownIt-Anchor" href="#相对寻址"></a> 相对寻址</h5>
<p>EA = (PC) + A，使用程序计数器 PC 提供基准地址（主存），指令字中的形式地址 A 给出相对位移量</p>
<p>此处 A 称为偏移量，可正可负，通常用补码表示</p>
<p>该偏移量实质上是以下条指令在内存中的首地址为基准的位置偏移量（因为是 PC 值）</p>
<p>基于程序的局部性原理</p>
<p>用处：</p>
<ol>
<li>
<p>代码模块可采用浮动地址，程序在内存中可任意放置</p>
</li>
<li>
<p>编程只需确定程序内部操作数与指令之间的相对距离，而无需确定操作数在主存储器中的绝对地址，这样，程序可以安排在主存的任意位置而不会影响其正确性</p>
</li>
<li>
<p>广泛应用于<strong>转移类指令</strong>，转移地址随 PC 值变化（注意 <strong>PC 先自增</strong>）</p>
</li>
</ol>
<h5 id="基址寻址"><a class="markdownIt-Anchor" href="#基址寻址"></a> 基址寻址</h5>
<p>EA = (BR) + A，使用基址寄存器提供基准地址（主存），指令字中的形式地址 A 给出相对偏移量</p>
<p>基址寄存器 BR (Base Address Register)：专用（隐式）、通用（显式）</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230724114420247.png" width="800px"/></dev>
<blockquote>
<p>注意看指令格式</p>
</blockquote>
<p>基址寄存器面向操作系统。其内容由操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性</p>
<p>在程序执行过程中，基址寄存器内容不变（作为基地址），形式地址 A 可变（作为偏移量）</p>
<p>优点：</p>
<ol>
<li>扩大寻址范围（基址寄存器位数 ＞ 形式地址 A 的位数）</li>
<li>用于为程序或数据分配存储空间，实现存储透明性：用户不必考虑自己的程序在主存中的位置，由 OS 或管理程序根据主存情况，赋予基址寄存器一个初始基地址。用户在程序执行过程中不可修改基址寄存器的内容</li>
<li>实现段寻址：将主存空间分为若干段，每段的首地址存于基址寄存器，段内偏移量由指令字中的形式地址 A 指出</li>
<li>可用于编制浮动程序</li>
<li>适用于<strong>多道程序设计</strong>，常用于为程序或数据分配存储空间</li>
</ol>
<p>缺点：偏移量（形式地址 A）的位数较短</p>
<blockquote>
<p>王道 P160 11：在多道程序设计中，最重要的寻址方式是（A）<br />
A. 相对寻址  B. 间接寻址  C. 立即寻址  D. 按内容寻址</p>
</blockquote>
<h5 id="变址寻址"><a class="markdownIt-Anchor" href="#变址寻址"></a> 变址寻址</h5>
<p>EA = A + (IX)，使用指令字中的形式地址 A 提供基准地址，寄存器中含有相对偏移量</p>
<p>变址寄存器 IX (Index Register)：专用（隐式）、通用（显式）</p>
<p>IX 面向用户，其内容由用户设定，在程序执行过程中可变（作为偏移量），但形式地址 A 的内容不可变（作为基地址）</p>
<p>优点：</p>
<ol>
<li>扩大寻址范围（IX 位数大于形式地址 A 的位数），偏移量足以表示整个存储空间</li>
<li>常用于需要频繁修改操作数地址的处理，如<strong>数组运算</strong>、字符串操作以及循环重复等，特别适合<strong>编制循环程序</strong></li>
</ol>
<h4 id="复合寻址"><a class="markdownIt-Anchor" href="#复合寻址"></a> 复合寻址</h4>
<p>如基址变址寻址（先基址再变址）：EA = (IX) + ((BR) + A)</p>
<h4 id="堆栈寻址"><a class="markdownIt-Anchor" href="#堆栈寻址"></a> 堆栈寻址</h4>
<p>堆栈是存储器（或专用寄存器组）中一块特定的、按后进先出 LIFO 原则管理的存储区（数据存取只在栈顶地址进行）</p>
<p>该存储区读/写单元（即栈顶）的地址用一个特定的寄存器给出，称为堆栈指针 SP。通常情况下，在读/写栈顶前后都伴有自动完成对 SP 内容的增量或减量操作</p>
<p>要求计算机系统中设有堆栈才能实现</p>
<p>堆栈的两种形式：</p>
<ol>
<li>
<p>硬堆栈/寄存器堆栈：寄存器组</p>
<p>成本较高，不适合做大容量的堆栈</p>
</li>
<li>
<p>软堆栈：主存的一部分空间</p>
</li>
</ol>
<p>可视为是一种隐含寻址：操作数地址隐含为 SP</p>
<p>可视为是一种寄存器间接寻址：SP 为寄存器，存放操作数有效地址</p>
<p>在采用堆栈结构的计算机系统中，大部分指令表面上都表现为无操作数指令的形式</p>
<hr />
<ul>
<li>
<p>数据寻址方式示意图</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3377_1.png" width="700px"/></dev>
</li>
<li>
<p>基本的数据寻址方式分析</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20231206161300388.png" width="900px"/></dev>
<p>隐含寻址、立即寻址、寄存器寻址访存次数为 0，获取操作数速度比较快。其中隐含寻址获取操作数速度最快，立即寻址次之，寄存器寻址再次之。立即寻址的指令执行时间最短</p>
<p>寄存器间接一次寻址取操作数速度接近直接寻址</p>
</li>
<li>
<p>对于一个指令系统来说，寻址方式多和少有什么影响？</p>
<p>寻址方式的多样化能让用户编程更为方便，但多重寻址方式会造成 CPU 结构的复杂化，也不利于指令流水线的运行</p>
<p>寻址方式太少虽能提高 CPU 的效率，但对用户而言，少数几种寻址方式会使编程变得复杂，很难满足用户需求</p>
</li>
</ul>
<h2 id="程序的机器级代码表示"><a class="markdownIt-Anchor" href="#程序的机器级代码表示"></a> 程序的机器级代码表示</h2>
<h3 id="常用汇编指令介绍"><a class="markdownIt-Anchor" href="#常用汇编指令介绍"></a> 常用汇编指令介绍</h3>
<h4 id="定点寄存器组"><a class="markdownIt-Anchor" href="#定点寄存器组"></a> 定点寄存器组</h4>
<p>x86 处理器（IA-32）中可见寄存器主要分为定点寄存器组、浮点寄存器栈和多媒体扩展寄存器组</p>
<blockquote>
<p>浮点寄存器栈和多媒体扩展寄存器组属于 IA-32 的浮点处理架构。前者用于浮点运算器 FPU，后者用于 SSE 架构（由多媒体扩展 MMX 技术发展而来，采用单指令多数据 SIMD 技术）</p>
</blockquote>
<p>定点寄存器组中共有 8 个通用寄存器 GPR (General Purpose Register)、2 个专用寄存器、6 个段寄存器</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230725101846552.png" width="600px"/></dev>
<h5 id="通用寄存器"><a class="markdownIt-Anchor" href="#通用寄存器"></a> 通用寄存器</h5>
<p>用于存放操作数（包括源操作数、目的操作数、中间结果）和各种地址信息等</p>
<p>为了向后兼容，EAX、EBX、ECX、EDX 的高两位字节和低两位字节可以独立使用（E 为 Extend，表示 32 位的寄存器），而低两位字节又可分别作为两个 8 位寄存器</p>
<p>BP/EBP 和 SP/ESP 分别是帧指针寄存器和栈指针寄存器，分别用来指向<strong>当前过程</strong>的栈帧的底部和顶部</p>
<p>除 EBP 和 ESP 外，其他几个寄存器的用途比较任意</p>
<p>EAX、ECX、EDX 属于调用者保存寄存器，EBX、ESI、EDI 属于被调用者保存寄存器。另外，调用者的 EBP 值会由被调用者的第一个指令压入被调用者的栈帧中（显然是保存在被调用者栈帧的栈底）</p>
<h5 id="专用寄存器"><a class="markdownIt-Anchor" href="#专用寄存器"></a> 专用寄存器</h5>
<p>两个专用寄存器分别是指令指针寄存器 EIP/IP (Extend Instruction Point) 和状态标志寄存器 FLAGS/EFLAGS</p>
<p>实地址模式时，使用 16 位的 IP 和 FLAGS 寄存器；保护模式时，使用 32 位的 EIP 和 EFLAGS 寄存器</p>
<ul>
<li>
<p>指令指针寄存器</p>
<p>与程序计数器 PC 功能完全一样，只是名称不同</p>
<blockquote>
<p>王道书和考题将指令指针寄存器或程序计数器简化，设定其存储的是物理地址。实际上 IA-32 中存储的是有效地址（即段内偏移）</p>
<p>咸鱼说存的是虚拟地址！</p>
</blockquote>
</li>
<li>
<p>状态标志寄存器</p>
<p>主要用于记录机器的状态和控制信息</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230726173618612.png" width="800px"/></dev>
<p>0~11 位中的 9 个标志位是从最早的 8086 微处理器延续下来，它们按功能可以分为 6 个条件标志和 3 个控制标志</p>
<p>条件标志用来存放运行的状态信息，由硬件自动设定。条件标志有时也称为条件码</p>
<p>控制标志由软件设定，用于中断响应、串操作和单步执行等</p>
<p>EFLAGS 寄存器的第 12~31 位中的其他状态或控制信息是从 80286 以后逐步添加的。包括用于表示当前程序的 I/O 特权级（IOPL）、当前任务是否是嵌套任务（NT）、当前处理器是否处于虚拟 8086 方式（VM）等一些状态或控制信息</p>
</li>
<li>
<p>常用条件标志含义</p>
<ol>
<li>
<p>OF (<strong>O</strong>verflow Flag)：溢出标志</p>
<p>反映<strong>带符号数</strong>的运算结果是否超过相应数值范围</p>
<p>溢出时 OF = 1，否则 OF = 0</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>F</mi><mo>=</mo><msub><mi>C</mi><mi>n</mi></msub><mo>⊕</mo><msub><mi>C</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">OF=C_{n} \oplus C_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>对无符号数运算没有意义</p>
</li>
<li>
<p>SF (<strong>S</strong>ign Flag)：符号标志</p>
<p>反映<strong>带符号数</strong>运算结果的符号</p>
<p>负数时 SF = 1，否则 SF = 0</p>
<p>对无符号数运算没有意义</p>
</li>
<li>
<p>ZF (<strong>Z</strong>ero Flag)：零标志</p>
<p>反映运算结果是否为 0</p>
<p>结果为 0 时 ZF = 1，否则 ZF = 0</p>
</li>
<li>
<p>CF (<strong>C</strong>arry Flag)：进/借位标志</p>
<p>反映<strong>无符号整数</strong>加（减）运算后的进（借）位情况</p>
<p>有进（借）位时 CF = 1，否则 CF = 0</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>F</mi><mo>=</mo><msub><mi>C</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mo>⊕</mo><mi>S</mi><mi>u</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">CF=C_{out} \oplus Sub</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>u</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">Sub</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span></span></span></span> 作为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_{in}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）</p>
<p>对带符号数运算没有意义</p>
</li>
</ol>
<blockquote>
<p>不论是无符号数还是带符号数，都以二进制代码形式无差别存放在机内，加法器不加以区分，条件标志也按照自己的规则生成，只是不一定有意义</p>
</blockquote>
</li>
<li>
<p>控制标志含义</p>
<ol>
<li>
<p>DF (<strong>D</strong>irection Flag)：方向标志</p>
<p>用来确定串操作指令执行时变址寄存器 SI/ESI 和 DI/EDI 中的内容是自动递增还是递减</p>
<p>递减时 DF = 1，递增时 DF = 0</p>
</li>
<li>
<p>IF (<strong>I</strong>nterrupt Flag)：中断允许标志</p>
<p>IF = 1 允许响应中断，IF = 0 禁止响应中断</p>
<p>IF 对非屏蔽中断和内部异常不起作用，仅对外部可屏蔽中断起作用</p>
</li>
<li>
<p>TF (<strong>T</strong>rap Flag)：陷阱标志</p>
<p>用来控制单步执行操作</p>
<p>TF = 1 时将开启单步调试模式，每个指令被执行后都将产生一个调试异常，以便于观察指令执行后的情况，此时可控制在每执行完一条指令后就把该指令执行得到的机器状态（包括各寄存器和存储单元的值等）显示出来</p>
</li>
</ol>
</li>
</ul>
<h5 id="段处理器"><a class="markdownIt-Anchor" href="#段处理器"></a> 段处理器</h5>
<p>6 个段寄存器都是 16 位</p>
<p>CPU 根据段寄存器的内容，与寻址方式确定的有效地址一起，并结合其他用户不可见的内部寄存器，生成操作数所在的存储地址</p>
<p>据说保护模式下 CS 寄存器的低两位决定了当前 CPU 的特权等级</p>
<h4 id="汇编指令格式"><a class="markdownIt-Anchor" href="#汇编指令格式"></a> 汇编指令格式</h4>
<p>基于 x86 架构的处理器所使用的汇编指令一般有两种格式：AT&amp;T 格式和 Intel 格式，二者区别如下：</p>
<p>① AT&amp;T 格式的指令只能用小写字母，Intel 格式的指令对大小写不敏感</p>
<p>② AT&amp;T 格式中，第一个为源操作数，第二个为目的操作数，方向从左到右；Intel 格式中，第一个为目的操作数，第二个为源操作数，方向从右到左</p>
<p>③ AT&amp;T 格式中，寄存器需要加前缀 %，立即数需要加前缀 $；Intel 格式中寄存器和立即数都不需要加前缀</p>
<p>④ 在<strong>内存</strong>寻址方面， AT&amp;T 格式使用 <code>(</code> 和 <code>)</code>，Intel 格式使用 <code>[</code> 和 <code>]</code></p>
<p>⑤ 在处理复杂寻址方式时，例如 AT&amp;T 格式的内存操作数 <code>disp(base, index, scale)</code> 分别表示偏移量、基址寄存器、变址寄存器和比例因子，如 <code>8(%edx, %eax, 2)</code> 表示操作数为 M[R[edx] + R[eax] * 2 + 8]， 其对应的 Intel 格式的操作数为 <code>[edx + eax * 2 + 8]</code></p>
<p>⑥ 在指定数据长度方面，AT&amp;T 格式指令操作码后面紧跟一个字符，表示操作数大小，b 表示字节 byte，w 表示字 word，l 表示双字 long；Intel 格式也有类似的语法，它在操作码后面显式地注明 byte ptr、word ptr 或 dword ptr</p>
<blockquote>
<p>由于 32 或 64 位体系结构都是由 16 位扩展而来，因此用 word（字）表示 16 位</p>
</blockquote>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230724220210988.png" width="800px"/></dev>
<blockquote>
<p>mov 指令用于在内存和寄存器之间或者寄存器之间移动数据<br />
lea 指令用于将一个内存地址（非其所指内容）或运算结果加载到目的寄存器</p>
</blockquote>
<h4 id="常用指令intel-格式"><a class="markdownIt-Anchor" href="#常用指令intel-格式"></a> 常用指令（Intel 格式）</h4>
<p>常用标记：</p>
<ul>
<li>
<p><strong>&lt;reg&gt;</strong> 表示任意寄存器，若其后带有数字，则指定其位数</p>
<p>&lt;reg32&gt; 表示 32 位寄存器（eax、ebx、ecx、edx、esi、edi、esp、ebp）</p>
<p>&lt;reg16&gt; 表示 16 位寄存器（ax、bx、cx、dx）</p>
<p>&lt;reg8&gt; 表示 8 位寄存器（ah、al、bh、bl、ch、cl、dh、dl）</p>
</li>
<li>
<p><strong>&lt;mem&gt;</strong> 表示内存地址</p>
<p>如 <code>[eax]</code>、<code>[var + 4]</code>、<code>dword ptr [eax + ebx]</code></p>
</li>
<li>
<p><strong>&lt;con&gt;</strong> 表示常数</p>
<p>&lt;con8&gt; 表示 8 位常数，&lt;con16&gt; 表示 16 位常数，&lt;con32&gt; 表示 32 位常数</p>
</li>
</ul>
<p>x86 中的指令机器码长度为 1 字节</p>
<p>汇编指令通常可分为数据传送指令、逻辑计算指令和控制流指令</p>
<h5 id="数据传送指令"><a class="markdownIt-Anchor" href="#数据传送指令"></a> 数据传送指令</h5>
<ul>
<li>
<p>mov 指令</p>
<p>将第二个操作数（寄存器的内容/内存中的内容/常数值）复制到第一个操作数（寄存器/内存），但不能直接从内存复制到内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov &lt;reg&gt;, &lt;reg&gt;</span><br><span class="line">mov &lt;reg&gt;, &lt;mem&gt;</span><br><span class="line">mov &lt;mem&gt;, &lt;reg&gt;</span><br><span class="line">mov &lt;reg&gt;, &lt;con&gt;</span><br><span class="line">mov &lt;mem&gt;, &lt;con&gt;</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, ebx           #将ebx值复制到eax</span><br><span class="line">mov byte ptr [var], 5  #将5保存到var值指示的内存地址的一字节中</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>push 指令</p>
<p>将操作数压入内存的栈，常用于函数调用</p>
<p>ESP 是栈顶，压栈前先将 ESP 值减 4（栈增长方向与内存地址增长方向相反），然后将操作数压入 ESP 指示的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push &lt;reg32&gt;</span><br><span class="line">push &lt;mem&gt;</span><br><span class="line">push &lt;con32&gt;</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push eax    #将eax值压栈</span><br><span class="line">push [var]  #将var值指示的内存地址的4字节值压栈</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>pop 指令</p>
<p>执行出栈操作</p>
<p>出栈前先将 ESP 指示的地址中的内容出栈，然后将 ESP 值加 4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop edi    #弹出栈顶元素送到edi</span><br><span class="line">pop [ebx]  #弹出栈顶元素送到ebx指示的内存地址的4字节中</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="算术和逻辑运算指令"><a class="markdownIt-Anchor" href="#算术和逻辑运算指令"></a> 算术和逻辑运算指令</h5>
<ul>
<li>
<p>add/sub 指令</p>
<p>结果保存到第一个操作数中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add &lt;reg&gt;, &lt;reg&gt; / sub &lt;reg&gt;, &lt;reg&gt;</span><br><span class="line">add &lt;reg&gt;, &lt;mem&gt; / sub &lt;reg&gt;, &lt;mem&gt;</span><br><span class="line">add &lt;mem&gt;, &lt;reg&gt; / sub &lt;mem&gt;, &lt;reg&gt;</span><br><span class="line">add &lt;reg&gt;, &lt;con&gt; / sub &lt;reg&gt;, &lt;con&gt;</span><br><span class="line">add &lt;mem&gt;, &lt;con&gt; / sub &lt;mem&gt;, &lt;con&gt;</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub eax, 10             #eax ← eax - 10</span><br><span class="line">add byte ptr [var], 10  #var值指示的内存地址的一字节值与10相加，并将结果保存在var值指示的内存地址的字节中</span><br></pre></td></tr></table></figure>
<blockquote>
<p>AT&amp;T：<code>sub source，destination</code>，destination ← destination - source</p>
</blockquote>
<blockquote>
<p>adc 带进位加法，在求和运算时再多加上 CF 标志位；sbb 带借位减法，减法运算时再多减去 CF 标志位</p>
</blockquote>
</li>
<li>
<p>inc/dec 指令</p>
<p>自加 1/自减 1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inc &lt;reg&gt; / dec &lt;reg&gt;</span><br><span class="line">inc &lt;mem&gt; / dec &lt;mem&gt;</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dec eax              #eax值自减1</span><br><span class="line">inc dword ptr [var]  #var值指示的内存地址的4字节值自加1</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>imul 指令</p>
<p>带符号整数乘法指令</p>
<p>有两种格式：① 两个操作数，将两个操作数相乘，将结果保存在第一个操作数中；② 三个操作数，将第二个操作数和第三个操作数相乘，将结果保存在第一个操作数中</p>
<p>两种格式的<strong>第一个操作数都必须为寄存器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">imul &lt;reg32&gt;, &lt;reg32&gt;</span><br><span class="line">imul &lt;reg32&gt;, &lt;mem&gt;</span><br><span class="line">imul &lt;reg32&gt;, &lt;reg32&gt;, &lt;con&gt;</span><br><span class="line">imul &lt;reg32&gt;, &lt;mem&gt;, &lt;con&gt;</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imul eax, [var]    #eax ← eax * [var]</span><br><span class="line">imul esi, edi, 25  #esi ← edi * 25</span><br></pre></td></tr></table></figure>
<p>乘法操作结果可能溢出，则编译器置溢出标志 OF = 1，以使 CPU 调出溢出异常处理程序</p>
</li>
<li>
<p>idiv 指令</p>
<p>带符号整数除法指令</p>
<p>只有一个操作数，代表除数，被除数为 edx:eax 中的内容（64 位整数）</p>
<p>操作结果有两部分：商和余数。商送到 eax，余数送到 edx</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idiv &lt;reg32&gt;</span><br><span class="line">idiv &lt;mem&gt;</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idiv ebx</span><br><span class="line">idiv dword ptr [var]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>and/or/xor 指令</p>
<p>逻辑与/逻辑或/逻辑异或操作指令，用于操作数的位操作</p>
<p>操作结果放在第一个操作数中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">and &lt;reg&gt;, &lt;reg&gt; / or &lt;reg&gt; &lt;reg&gt; / xor &lt;reg&gt;, &lt;reg&gt;</span><br><span class="line">and &lt;reg&gt;, &lt;mem&gt; / or &lt;reg&gt; &lt;mem&gt; / xor &lt;reg&gt;, &lt;mem&gt;</span><br><span class="line">and &lt;mem&gt;, &lt;reg&gt; / or &lt;mem&gt; &lt;reg&gt; / xor &lt;mem&gt;, &lt;reg&gt;</span><br><span class="line">and &lt;reg&gt;, &lt;con&gt; / or &lt;reg&gt; &lt;con&gt; / xor &lt;reg&gt;, &lt;con&gt;</span><br><span class="line">and &lt;mem&gt;, &lt;con&gt; / or &lt;mem&gt; &lt;con&gt; / xor &lt;mem&gt;, &lt;con&gt;</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and eax, 0fH  #将eax中的前28位置0,最后4位保持不变</span><br><span class="line">xor edx, edx  #将eax中的内容全部置0</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>not 指令</p>
<p>位翻转指令，将操作数中的每一位翻转（0→1、1→0）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">not &lt;reg&gt;</span><br><span class="line">not &lt;mem&gt;</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not byte ptr [var]  #将var值指示的内存地址的一字节的所有位翻转</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>neg 指令</p>
<p>取负指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">neg &lt;reg&gt;</span><br><span class="line">neg &lt;mem&gt;</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neg eax  #eax ← -eax</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>shl/shr 指令</p>
<p>逻辑移位指令，shl 逻辑左移，shr 逻辑右移</p>
<p>第一个操作数表示被操作数，第二个操作数指示移位的位数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shl &lt;reg&gt;, &lt;con8&gt; / shr &lt;reg&gt;, &lt;con8&gt;</span><br><span class="line">shl &lt;mem&gt;, &lt;con8&gt; / shr &lt;mem&gt;, &lt;con8&gt;</span><br><span class="line">shl &lt;reg&gt;, &lt;cl&gt; / shr &lt;reg&gt;, &lt;cl&gt;</span><br><span class="line">shl &lt;mem&gt;, &lt;cl&gt; / shr &lt;mem&gt;, &lt;cl&gt;</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shl eax, 1   #将eax值左移1位</span><br><span class="line">shr ebx, cl  #将ebx值右移n位(n为cl中的值)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="控制流指令"><a class="markdownIt-Anchor" href="#控制流指令"></a> 控制流指令</h5>
<p>x86 处理器中的程序计数器为 IP。IP 寄存器不能直接操作，但可以用控制流指令更新</p>
<p>通常用标签(label)指示程序中的指令地址。在 x86 汇编代码中，可在任何指令之前加入标签，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       mov esi, [ebp+8]</span><br><span class="line">begin: xor ecx, ecx</span><br><span class="line">       mov eax, [esi]</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>jmp 指令</p>
<p>控制 IP 转移到 label 所指示的地址（从 label 中取出指令执行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp &lt;label&gt;</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp begin  #跳转到begin标记的指令执行</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>jcondition 指令</p>
<p>条件转移指令，依据 CPU 状态字中的一系列条件状态（ZF 和 SF）转移</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">je &lt;label&gt;   #jump when equal</span><br><span class="line">jne &lt;label&gt;  #jump when not equal</span><br><span class="line">jz &lt;label&gt;   #jump when last result zero</span><br><span class="line">#signed</span><br><span class="line">jg &lt;label&gt;   #jump when greater than</span><br><span class="line">jge &lt;label&gt;  #jump when greater than or equal to</span><br><span class="line">jl &lt;label&gt;   #jump when less than</span><br><span class="line">jle &lt;label&gt;  #jump when less than or equal to</span><br><span class="line">#unsigned</span><br><span class="line">ja &lt;label&gt;   #jump when above</span><br><span class="line">jae &lt;label&gt;  #jump when above or equal to</span><br><span class="line">jb &lt;label&gt;   #jump when below</span><br><span class="line">jbe &lt;label&gt;  #jump when below or equal to</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp eax, ebx</span><br><span class="line">jle done      #如果eax的值小于等于ebx值,跳转到done指示的指令执行,否则执行下一条指令</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>cmp/test 指令</p>
<p>cmp 指令用于比较两个操作数的值；test 指令对两个操作数进行逐位与运算</p>
<p>这两类指令都不保存操作结果，仅根据运算结果设置 CPU 状态字中的条件码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmp &lt;reg&gt;, &lt;reg&gt; / test &lt;reg&gt;, &lt;reg&gt;</span><br><span class="line">cmp &lt;reg&gt;, &lt;mem&gt; / test &lt;reg&gt;, &lt;mem&gt;</span><br><span class="line">cmp &lt;mem&gt;, &lt;reg&gt; / test &lt;mem&gt;, &lt;reg&gt;</span><br><span class="line">cmp &lt;reg&gt;, &lt;con&gt; / test &lt;reg&gt;, &lt;con&gt;</span><br></pre></td></tr></table></figure>
<p>cmp 和 test 指令通常和 jcondition 指令搭配使用，举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmp dword ptr [var], 10  #将var指示的主存地址的4字节内容与10比较</span><br><span class="line">jne loop                 #如果相等则继续顺序执行,否则跳转到loop处执行</span><br><span class="line">test eax, eax            #测试eax是否为零</span><br><span class="line">jz xxxx                  #为零则置标志ZF为1,跳转到xxxx处执行</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>call/ret 指令</p>
<p>分别用于实现子程序（过程、函数等）的调用及返回，都属于无条件转移指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call &lt;label&gt;</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>call 指令先将位于其下条指令的地址入栈（作为返回地址），然后无条件转移到由标签指示的指令</p>
<p>与其他简单的跳转指令不同，call 指令保存调用之前的地址信息（当 call 指令结束后，返回调用之前的地址）</p>
<p>ret 指令实现子程序的返回机制：ret 指令弹出栈中保存的返回地址（相当于 pop 指令），并送到 EIP 寄存器（段内或段间调用时）和 CS 寄存器（仅段间调用），即无条件转移到返回地址执行</p>
<p>若 ret 指令带有一个立即数 n，则当它完成上述操作后，还会执行 R[esp] ← R[esp] + n 操作，从而实现预定的修改栈指针的目的</p>
<p>call 和 ret 是程序（函数）调用中最关键的两条指令</p>
</li>
</ul>
<h3 id="过程调用的机器级表示"><a class="markdownIt-Anchor" href="#过程调用的机器级表示"></a> 过程调用的机器级表示</h3>
<ul>
<li>
<p>过程调用的执行步骤</p>
<p>假定过程 P 调用过程 Q</p>
<ol>
<li>P 将入口参数（实参）放在 Q 能访问到的地方</li>
<li>P 将返回地址存到特定的地方，然后将控制转移到 Q（call 指令）</li>
<li>Q 保存 P 的现场（通用寄存器的内容），并为自己的非静态局部变量分配空间</li>
<li>执行过程 Q</li>
<li>Q 恢复 P 的现场，将返回结果放到 P 能访问到的地方，并释放局部变量所占空间</li>
<li>Q 取出返回地址，将控制转移到 P（ret 指令）</li>
</ol>
</li>
<li>
<p>需要存放的数据</p>
<p>入口参数、返回地址、调用过程的现场、被调用过程中的非静态局部变量、返回结果等</p>
</li>
<li>
<p>调用者保存寄存器（EAX、ECX、EDX）</p>
<p>保存和恢复的任务由调用者负责</p>
<p>当 P 调用 Q 时，Q 就可以直接使用这三个寄存器（这意味着 P 应在转到 Q 之前先保存它们的值，并在从 Q 返回之后先恢复它们的值再使用）</p>
</li>
<li>
<p>被调用者保存寄存器（EBX、ESI、EDI）</p>
<p>保存和恢复的任务由被调用者负责</p>
<p>Q 必须先将它们的原值保存在栈中才能使用它们，并且在返回 P 之前恢复</p>
<blockquote>
<p>调用过程的 EBP 亦由被调用过程保存（<code>push %ebp</code>）和恢复（<code>leave</code> 或 <code>mov %ebp, %esp; pop %ebp</code>）</p>
</blockquote>
</li>
<li>
<p>栈与栈帧</p>
<p>每个过程都有自己的栈区，称为栈帧，一个栈由若干栈帧组成</p>
<p>IA-32 使用栈来支持过程的嵌套调用，过程的入口参数、返回地址、被保存寄存器的值、被调用过程中的非静态局部变量等都会被压入栈中，IA-32 中可通过执行 MOV、PUSH、POP 指令存取栈中元素</p>
<p>帧指针寄存器 EBP 指示<strong>栈帧的栈底</strong>，栈指针寄存器 ESP 指示<strong>栈帧的栈顶</strong></p>
<p>栈从高地址向低地址增长</p>
</li>
<li>
<p>过程调用过程中栈和栈帧的变化</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230726170916998.png" width="800px"/></dev>
<p>在过程 P 中遇到一个函数调用：</p>
<ol>
<li>首先，P 确定是否需要将某些调用者保存寄存器（如 EAX、ECX 和 EDX）保存到自己的栈中</li>
<li>然后，将入口参数按序保存到 P 的栈中，参数压栈的顺序是<strong>先右后左</strong></li>
<li>最后执行 CALL 指令，先将返回地址保存到 P 的栈中，然后转去执行被调用过程 Q</li>
</ol>
<p>在执行被调用函数 Q 的准备阶段：</p>
<ol>
<li>
<p>首先，Q 将 EBP 的旧值保存到自己的栈中并设置 EBP 指向它</p>
</li>
<li>
<p>然后，根据需要确定是否将被调用者寄存器（如 EBX、ESI、EDI）保存到栈帧中</p>
</li>
<li>
<p>最后在栈中为非静态局部变量分配空间</p>
<p>通常，如果非静态局部变量为简单变量且有空闲的通用寄存器，则编译器会将通用寄存器分配给局部变量，但是，对于非静态局部变量是数组或结构等复杂数据类型的情况，则只能在栈中为其分配空间</p>
</li>
</ol>
<p>在 Q 过程体执行后的结束阶段，会恢复被调用者保存寄存器和 EBP 寄存器的值，并使 ESP 指向返回地址，这样栈中的状态又回到了调用 Q 前的状态。这时执行 RET 指令便能取出返回地址，以回到过程 P 继续执行</p>
<p>从图 b 可看出，在 Q 的过程体执行时，入口参数 1 的地址总是 R[ebp] + 8，入口参数 2 的地址总是 R[ebp]+12，入口参数 3 的地址总是 R[ebp]+16，依此类推……</p>
</li>
<li>
<p>简单的 C 语言程序对应的过程调用的机器级实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">caller</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp1 = <span class="number">125</span>;</span><br><span class="line">    <span class="type">int</span> temp2 = <span class="number">80</span>;</span><br><span class="line">    <span class="type">int</span> sum = add(temp1, temp2);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经 GCC 编译后，caller 过程（不包含 add 过程）对应的代码如下（设 P 调用 caller）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">caller:</span><br><span class="line">pushl %ebp             #P栈底指针值压栈</span><br><span class="line">movl  %esp, %ebp       #当前栈顶作为caller栈底</span><br><span class="line">subl  $24, %esp        #移动栈顶指针,为caller参数分配24字节空间(6个双字)</span><br><span class="line">movl  $125, -12(%ebp)  #125→M[R[ebp]-12],保存局部变量temp1值到栈帧</span><br><span class="line">movl  $80, -8(%ebp)    #80→M[R[ebp]-8],保存局部变量temp2值到栈帧</span><br><span class="line">movl  -8(%ebp), %eax   #M[R[ebp]-8]→R[eax],add入口参数temp2值复制到eax</span><br><span class="line">mov   %eax, 4(%esp)    #R[eax]→M[R[esp]+4],保存add入口参数temp2值到栈帧(从eax)</span><br><span class="line">movl  -12(%ebp), %eax  #M[R[ebp]-12]→R[eax],add入口参数temp1值复制到eax</span><br><span class="line">movl  %eax, (%esp)     #R[eax]→M[R[esp]],保存add入口参数temp2值到栈帧(从eax)</span><br><span class="line">call  add              #把返回地址(即第12行指令地址)压栈,调用add,并将add返回值保存在eax中</span><br><span class="line">movl  %eax, -4(%ebp)   #R[eax]→M[R[ebp]-4],add返回值送局部变量sum并保存到栈帧</span><br><span class="line">movl  -4(%ebp), %eax   #M[R[ebp]-4]→R[eax],sum作为caller返回值保存到eax</span><br><span class="line">leave</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>执行第 4 行后 ESP 所指位置如下图所示：</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20231108155526835.png" width="500px"/></dev>
<p>caller 栈帧用到的空间占 4 (P 的 EBP 值) + 12 (3 个局部变量) + 8 (add 的 2 个入口参数) + 4 (call 指令设置的 add 调用结束后的返回地址) = 28 字节，但栈帧共有 4 + 24 + 4 = 32 字节（一开始为 caller 参数分配的 24 字节空间只用了 20 字节），有 4 字节空间被浪费。这是因为 GCC 为保证数据的严格对齐而规定每个函数的栈帧大小必须是 16 字节的倍数</p>
<p>执行 ret 指令之前，应将当前栈帧释放，并恢复旧 ESP 的值。leave 指令实现了这个功能，它相当于以下两条指令的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl %ebp, %esp  #使esp指向当前ebp的位置</span><br><span class="line">popl %ebp        #弹出当前esp所指位置的内容(P的栈底)并保存到ebp,同时esp也指向了P的栈顶(P设置的返回地址)</span><br></pre></td></tr></table></figure>
<p>编译器不一定要使用 leave 指令，也可通过 pop 执行和对 ESP 的内容做加法来实现退栈操作</p>
<p>add 过程经 GCC 编译并进行链接后，对应的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">8048469:55         push %ebp</span><br><span class="line">804846a:89 e5      mov  %esp, %ebp</span><br><span class="line">804846c:8b 45 0c   mov  0xc(%ebp), %eax</span><br><span class="line">804846f:8b 55 08   mov  0x8(%ebp), %edx</span><br><span class="line">8048472:8d 04 02   lea  (%edx, %eax, 1), %eax  #R[edx]+R[eax]*1→eax</span><br><span class="line">8048475:5d         pop  %ebp</span><br><span class="line">8048476:c3         ret</span><br></pre></td></tr></table></figure>
<p>add 过程没有用到任何被调用者保存寄存器，没有局部变量，此外，add 是一个被调用过程，并且不再调用其他过程，即它是一个叶子过程，因而也没有入口参数和返回地址要保存，因此，add 的栈帧中除了要保存 caller 的 EBP 以外，无须保留任何信息</p>
<p>通常一个过程对应的机器级代码都有三个部分：</p>
<ol>
<li>
<p>准备阶段（最简单的准备阶段代码段）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push %ebp</span><br><span class="line">mov  %esp, %ebp</span><br></pre></td></tr></table></figure>
<p>通过将当前栈指针 ESP 传送到 EBP 来完成将 EBP 指向当前栈帧底部的任务</p>
</li>
<li>
<p>过程体</p>
<p>很方便地通过 EBP 获取入口参数（从 R[ebp] + 8 开始往上）</p>
<p>lea 指令执行的是加法运算</p>
</li>
<li>
<p>结束阶段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leave</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov %ebp, %esp  #EBP和ESP已重合时可省,比如这里的add过程,整个过程体阶段没有压栈操作</span><br><span class="line">pop %ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>add 的 EBP 和 ESP 都指向保存有 caller EBP 值的单元，因此通过 pop 并将出栈值保存到 EBP 可以实现恢复 EBP 在 caller 过程中的值，并在栈中退出 add 过程的栈帧，同时执行到 ret 指令时 ESP 已指向返回地址</p>
</li>
</ol>
</li>
</ul>
<hr />
<p>C 语言有 9 种流程控制语句，分成三类：</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230726182013259.png" width="400px"/></dev>
<h3 id="选择语句的机器级表示"><a class="markdownIt-Anchor" href="#选择语句的机器级表示"></a> 选择语句的机器级表示</h3>
<ul>
<li>
<p>编译器通过条件码（标志位）设置指令和各类转移指令来实现程序中的选择结构语句</p>
</li>
<li>
<p>常见的算术逻辑运算指令（add、sub、imul、or、and、shl、inc、dec、not、sal 等）会设置条件码</p>
</li>
<li>
<p>只设置条件码而不改变任何其他寄存器的两类指令</p>
<ol>
<li>cmp 指令：与 sub 指令的行为一样</li>
<li>test 指令：与 and 指令的行为一样</li>
</ol>
<p>它们只设置条件码，而不更新目的寄存器</p>
</li>
<li>
<p>if 语句</p>
<p>if ~ (then)、if ~ (then) ~ else 语句通用形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cond_expr)</span><br><span class="line">    then_statement</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    else_statement</span><br></pre></td></tr></table></figure>
<p>编译后得到的对应汇编代码可以有如下两种不同的结构：</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230726182518610.png" width="600px"/></dev>
<p>对于下面的 C 语言函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_lowaddr_content</span><span class="params">(<span class="type">int</span> *p1, <span class="type">int</span> *p2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p1 &gt; p2)</span><br><span class="line">        <span class="keyword">return</span> *p2;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> *p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>已知形式参数 p1 和 p2 对应的实参已被压入调用函数的栈帧，p1 和 p2 对应实参的存储地址分别为 R[ebp] + 8、R[ebp] + 12。返回结果存放在 EAX 中</p>
<p>则上述函数体对应的汇编代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">movl 8(%ebp), %eax   #R[eax]←M[R[ebp]+8],即R[eax]=p1</span><br><span class="line">movl 12(%ebp), %edx  #R[edx]←M[R[ebp]+12],即R[edx]=p2</span><br><span class="line">cmpl %edx, %eax      #比较p1和p2,即根据p1-p2的结果置标志(右-左)</span><br><span class="line">jbe  .L1             #若pl&lt;=p2,则转标记L1处执行</span><br><span class="line">movl (%edx), %eax    #R[eax]←M[R[edx]],即R[eax]=M[p2]</span><br><span class="line">jmp  .L2             #无条件跳转到标记L2执行</span><br><span class="line">.L1:</span><br><span class="line">movl (%eax), %eax    #R[eax]←M[R[eax]],即R[eax]=M[p1]</span><br><span class="line">.L2:</span><br></pre></td></tr></table></figure>
<p>p1 和 p2 是指针型参数，故在 32 位机中的长度后缀是 l</p>
<p>比较指令 cmpl 的两个操作数都应来自寄存器 ，故应先将 p1 和 p2 对应的实参从栈中取到通用寄存器</p>
</li>
</ul>
<h3 id="循环语句的机器级表示"><a class="markdownIt-Anchor" href="#循环语句的机器级表示"></a> 循环语句的机器级表示</h3>
<p>C 语言循环结构有三种：while、do ~ while、for，大多数编译程序将这三种循环结构都转换为 do ~ while 形式来产生机器级代码</p>
<h4 id="do-~-while"><a class="markdownIt-Anchor" href="#do-~-while"></a> do ~ while</h4>
<p>C 语言形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    loop_body_statement</span><br><span class="line">&#125; <span class="keyword">while</span> (cond_expr);</span><br></pre></td></tr></table></figure>
<p>更接近于机器级语言的低级行为描述结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">	loop_body_statement</span><br><span class="line">	c = cond_expr;</span><br><span class="line">	if (c) goto loop;</span><br></pre></td></tr></table></figure>
<h4 id="while"><a class="markdownIt-Anchor" href="#while"></a> while</h4>
<p>C 语言形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (cond_expr)</span><br><span class="line">    loop_body_statement</span><br></pre></td></tr></table></figure>
<p>更接近于机器级语言的低级行为描述结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c = cond_expr;</span><br><span class="line">if (!c) goto done;</span><br><span class="line">loop:</span><br><span class="line">	loop_body_statement</span><br><span class="line">	c = cond_expr;</span><br><span class="line">	if (c) goto loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>
<h4 id="for"><a class="markdownIt-Anchor" href="#for"></a> for</h4>
<p>C 语言形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (begin_expr; cond_expr; update_expr)</span><br><span class="line">    loop_body_statement</span><br></pre></td></tr></table></figure>
<p>更接近于机器级语言的低级行为描述结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">begin_expr;</span><br><span class="line">c = cond_expr;</span><br><span class="line">if (!c) goto done;</span><br><span class="line">loop:</span><br><span class="line">	loop_body_statement</span><br><span class="line">	update_expr;</span><br><span class="line">	c = cond_expr;</span><br><span class="line">	if (c) goto loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>
<h4 id="汇编代码示例"><a class="markdownIt-Anchor" href="#汇编代码示例"></a> 汇编代码示例</h4>
<p>使用 for 循环写的自然数求和的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">nsum_for</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        result += i;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上述对应 for 循环的低级行为描述结构，不难写出上述过程对应的汇编表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">movl 8(%ebp), %ecx  #R[ecx]←M[R[ebp]+8],即R[ecx]=n</span><br><span class="line">movl $0, eax        #R[eax]←0,即result=0</span><br><span class="line">movl $1, edx        #R[edx]←1,即i=l</span><br><span class="line">cmp  %ecx, %edx     #Compare R[ecx]:R[edx],即比较i:n</span><br><span class="line">jg   .L2            #If greater，转跳到L2执行</span><br><span class="line">.L1:                #1OOP:</span><br><span class="line">addl %edx, %eax     #R[eax]←R[eax]+R[edx],即result+=i</span><br><span class="line">addl $1, %edx       #R[edx]←R[edx]+1,即i++</span><br><span class="line">cmpl %ecx, %edx     #比较%ecx和%edx,即比较i:n</span><br><span class="line">jle  .L1            #If less or equal,转跳到L1执行</span><br><span class="line">.L2:</span><br></pre></td></tr></table></figure>
<p>n 对应实参已被压入调用函数的栈帧，其对应的存储地址为 R[ebp] + 8，过程 nsum_for 中非静态局部变量 i 和 result 被分别分配到寄存器 EDX 和 EAX 中，返回参数在 EAX 中</p>
<h2 id="cisc-和-risc-的基本概念"><a class="markdownIt-Anchor" href="#cisc-和-risc-的基本概念"></a> CISC 和 RISC 的基本概念</h2>
<p>指令系统朝两个截然不同的方向发展：</p>
<ol>
<li>增强原有指令的功能，设置更为复杂的新指令实现软件功能的硬化（CISC）</li>
<li>减少指令种类和简化指令功能，提高指令的执行速度（RISC）</li>
</ol>
<h3 id="复杂指令系统计算机-cisc"><a class="markdownIt-Anchor" href="#复杂指令系统计算机-cisc"></a> 复杂指令系统计算机 CISC</h3>
<p>复杂指令集计算机 CISC (Complex Instruction Set Computer)</p>
<p>背景：随着超大规模集成电路 VLSI 技术发展，硬件成本不断下降，软件成本不断上升，促使人们在指令系统中增加更多、更复杂的指令，以适应不同的应用领域</p>
<p>中心思想：每个指令可执行若干低端操作，诸如从存储器读取、存储和计算操作，全部集于单一指令之中</p>
<p>主要特点：</p>
<ol>
<li>指令系统复杂庞大，指令数目一般为 200 条以上</li>
<li>指令长度不固定，指令格式多，寻址方式多</li>
<li>可以访存的指令不受限制</li>
<li>各种指令使用频度相差很大</li>
<li>各种指令执行时间相差很大，大多数指令需多个时钟周期才能完成</li>
<li>控制器大多数采用微程序控制。有些指令非常复杂，以至于无法采用硬连线控制</li>
<li>难以用优化编译生成高效的目标代码程序</li>
</ol>
<p>存在 <strong>80/20 规律</strong>：典型程序的 80% 的语句仅仅使用处理机中 20% 的指令，而且这些指令还都是简单指令<br />
这就告诫人们，就算付出很大代价增加复杂指令，也只有 20% 的使用概率，而且还增加了执行指令的开销</p>
<p>代表：x86</p>
<h3 id="精简指令系统计算机-risc"><a class="markdownIt-Anchor" href="#精简指令系统计算机-risc"></a> 精简指令系统计算机 RISC</h3>
<p>精简指令集计算机 RISC (Reduced Instruction Set Computer)</p>
<p>背景：CISC 指令系统庞大，指令设计要求极高，研制周期变得很长，后来人们发现一味地追求指令系统的复杂和完备程度不是提高计算机性能的唯一途径。。。</p>
<p>中心思想：简化指令系统，系统一条指令完成一个基本“动作”，多条指令组合完成一个复杂的基本功能。尽量使用寄存器-寄存器操作指令，指令格式力求一致</p>
<p>主要特点：</p>
<ol>
<li>选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现</li>
<li>指令长度固定，指令格式种类少，寻址方式种类少</li>
<li>只有 Load/Store (取数/存数) 指令可以访存，其余指令的操作都在寄存器之间进行</li>
<li>CPU 中通用寄存器的数量相当多</li>
<li><strong>一定</strong>采用指令流水线技术，<strong>大部分</strong>指令在一个时钟周期内完成</li>
<li>以硬布线控制为主，<strong>不用或少用</strong>微程序控制</li>
<li>特别重视编译优化工作，以减少程序执行时间</li>
</ol>
<p>代表：MIPS、RISC-V、ARM</p>
<hr />
<p><strong>装入/存储(Load/Store)型指令</strong></p>
<p>装入/存储型指令是用在规整型指令系统中的一种通用寄存器型指令风格。这种指令风格在 RISC 指令系统中较为常见</p>
<p>为了规整指令格式，使指令具有相同的长度，规定只有 Load/Store 指令才能访问内存。而运算指令不能直接访问内存，只能从寄存器取数进行运算，运算的结果也只能送到寄存器</p>
<p>因为寄存器编号较短，而主存地址位数较长，通过某种方式可使运算指令和访存指令的长度一致</p>
<p>这种装入/存储型风格的指令系统的最大特点是，指令格式规整，指令长度一致，一般为 32 位。由于只有 Load/Store 指令才能访问内存，程序中可能会包含许多装入指令和存储指令，与ー般通用寄存器型指令风格相比，其程序长度会更长</p>
<h3 id="cisc-vs-risc"><a class="markdownIt-Anchor" href="#cisc-vs-risc"></a> CISC vs RISC</h3>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3387_1.png" width="850px"/></dev>
<p>RISC <strong>必然采用</strong>流水线技术；CISC 无此强制要求，但为了提高指令执行速度，<strong>往往也采用</strong>流水线技术</p>
<p>RISC 主要优点（和 CISC 相比）：</p>
<ol>
<li>
<p>更能充分利用 VLSI 芯片的面积</p>
<p>CISC 的控制器大多采用微程序控制，其控制存储器在 CPU 芯片所占的面积达 50% 以上</p>
<p>RISC 的控制器采用组合逻辑控制，其硬布线逻辑只占 CPU 面积的 10% 左右</p>
</li>
<li>
<p>更能提高运算速度</p>
<p>RISC 指令数、寻址方式和指令格式少，又设有多个通用存储器，采用流水线技术，大多数指令在一个时钟周期内完成</p>
</li>
<li>
<p>RISC 便于设计，可降低成本，提高可靠性</p>
<p>RISC 指令系统简单，因此机器设计周期短；其逻辑简单，因此可靠性高</p>
</li>
<li>
<p>有利于编译程序代码优化</p>
<p>RISC 指令类型少，寻址方式少，使编译程序容易选择更有效的指令和寻址方式，并适当地调整指令顺序，使得代码执行更高效化</p>
</li>
</ol>
<p><strong>兼容性</strong>：虽说 RISC 具有更强的实用性，应是未来处理器的发展方向，但事实上，当今 Intel 几乎一统江湖，且早期很多软件都是根据 CISC 设计的，CISC 大多能实现向后兼容，并可加以而扩充。但 RISC 简化了指令系统，指令条数少，格式也不同于老机器，因此大多数 RISC 机不能与老机器兼容</p>
<p>现代 CISC 结构的 CPU 已经融合了很多 RISC 的成分，二者性能差距越来越小</p>
<h2 id="刷题笔记"><a class="markdownIt-Anchor" href="#刷题笔记"></a> 刷题笔记</h2>
<ul>
<li>看清题目要求的是操作数有效地址还是操作数本身！！！</li>
<li>条件转移指令 bgt（无符号整数比较大于时转移）的转移条件是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>C</mi><mi>F</mi><mo>+</mo><mi>Z</mi><mi>F</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\overline{CF+ZF}=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9666600000000001em;vertical-align:-0.08333em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.08333em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，即进位/借位标志 CF 和零标志 ZF 均为 0</li>
<li>内存地址是无符号数，不能为负</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zero</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zerooo.top/2024/01/06/CO4_%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/">https://zerooo.top/2024/01/06/CO4_%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zerooo.top" target="_blank">ZERO</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/06/CO5_%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">中央处理器 | CO</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/06/CO3_%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">存储系统 | CO</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/01/06/CO7_%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/" title="输入输出系统 | CO"><img class="cover" src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-06</div><div class="title">输入输出系统 | CO</div></div></a></div><div><a href="/2024/01/06/CO1_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" title="计算机系统概述 | CO"><img class="cover" src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-06</div><div class="title">计算机系统概述 | CO</div></div></a></div><div><a href="/2024/01/06/CO2_%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/" title="数据的表示与运算 | CO"><img class="cover" src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-06</div><div class="title">数据的表示与运算 | CO</div></div></a></div><div><a href="/2024/01/06/CO6_%E6%80%BB%E7%BA%BF/" title="总线 | CO"><img class="cover" src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-06</div><div class="title">总线 | CO</div></div></a></div><div><a href="/2024/01/06/CO3_%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/" title="存储系统 | CO"><img class="cover" src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-06</div><div class="title">存储系统 | CO</div></div></a></div><div><a href="/2024/01/06/CO5_%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/" title="中央处理器 | CO"><img class="cover" src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-06</div><div class="title">中央处理器 | CO</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zero</div><div class="author-info__description">一些记录</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zero-P" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:zerooop@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.</span> <span class="toc-text"> 指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text"> 指令的基本格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%B6%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 零地址指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 一地址指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 二地址指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">1.1.4.</span> <span class="toc-text"> 三地址指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">1.1.5.</span> <span class="toc-text"> 四地址指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%A0%81%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text"> 扩展操作码指令格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text"> 指令的操作类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 数据传送</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E5%92%8C%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 算术和逻辑运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.3.</span> <span class="toc-text"> 移位操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.4.</span> <span class="toc-text"> 转移操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.5.</span> <span class="toc-text"> 输入输出操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text"> 指令的寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80"><span class="toc-number">2.1.</span> <span class="toc-text"> 指令寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AF%BB%E5%9D%80"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 顺序寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E5%AF%BB%E5%9D%80"><span class="toc-number">2.1.2.</span> <span class="toc-text"> 跳跃寻址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.</span> <span class="toc-text"> 数据寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%90%AB%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 隐含寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E6%95%B0%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 立即（数）寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.3.</span> <span class="toc-text"> 直接寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.4.</span> <span class="toc-text"> 间接寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.5.</span> <span class="toc-text"> 寄存器寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.6.</span> <span class="toc-text"> 寄存器间接寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E7%A7%BB%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.7.</span> <span class="toc-text"> 偏移寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.7.1.</span> <span class="toc-text"> 相对寻址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.7.2.</span> <span class="toc-text"> 基址寻址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.7.3.</span> <span class="toc-text"> 变址寻址</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.8.</span> <span class="toc-text"> 复合寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E5%AF%BB%E5%9D%80"><span class="toc-number">2.2.9.</span> <span class="toc-text"> 堆栈寻址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.</span> <span class="toc-text"> 程序的机器级代码表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text"> 常用汇编指令介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 定点寄存器组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.1.1.1.</span> <span class="toc-text"> 通用寄存器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%93%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.1.1.2.</span> <span class="toc-text"> 专用寄存器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AE%B5%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">3.1.1.3.</span> <span class="toc-text"> 段处理器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 汇编指令格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4intel-%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.1.3.</span> <span class="toc-text"> 常用指令（Intel 格式）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">3.1.3.1.</span> <span class="toc-text"> 数据传送指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E5%92%8C%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-number">3.1.3.2.</span> <span class="toc-text"> 算术和逻辑运算指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E6%8C%87%E4%BB%A4"><span class="toc-number">3.1.3.3.</span> <span class="toc-text"> 控制流指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.2.</span> <span class="toc-text"> 过程调用的机器级表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.3.</span> <span class="toc-text"> 选择语句的机器级表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.4.</span> <span class="toc-text"> 循环语句的机器级表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#do-~-while"><span class="toc-number">3.4.1.</span> <span class="toc-text"> do ~ while</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#while"><span class="toc-number">3.4.2.</span> <span class="toc-text"> while</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for"><span class="toc-number">3.4.3.</span> <span class="toc-text"> for</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.4.4.</span> <span class="toc-text"> 汇编代码示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cisc-%E5%92%8C-risc-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.</span> <span class="toc-text"> CISC 和 RISC 的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%9C%BA-cisc"><span class="toc-number">4.1.</span> <span class="toc-text"> 复杂指令系统计算机 CISC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%9C%BA-risc"><span class="toc-number">4.2.</span> <span class="toc-text"> 精简指令系统计算机 RISC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cisc-vs-risc"><span class="toc-number">4.3.</span> <span class="toc-text"> CISC vs RISC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0"><span class="toc-number">5.</span> <span class="toc-text"> 刷题笔记</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/26/DS6_%E5%9B%BE/" title="图 | DS"><img src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="图 | DS"/></a><div class="content"><a class="title" href="/2024/01/26/DS6_%E5%9B%BE/" title="图 | DS">图 | DS</a><time datetime="2024-01-26T01:31:06.000Z" title="发表于 2024-01-26 09:31:06">2024-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/12/DS5_%E6%A0%91/" title="树 | DS"><img src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="树 | DS"/></a><div class="content"><a class="title" href="/2024/01/12/DS5_%E6%A0%91/" title="树 | DS">树 | DS</a><time datetime="2024-01-12T01:14:08.000Z" title="发表于 2024-01-12 09:14:08">2024-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/11/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" title="常用算法模板"><img src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用算法模板"/></a><div class="content"><a class="title" href="/2024/01/11/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" title="常用算法模板">常用算法模板</a><time datetime="2024-01-11T09:50:08.000Z" title="发表于 2024-01-11 17:50:08">2024-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/11/DS3_%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/" title="栈、队列和数组 | DS"><img src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="栈、队列和数组 | DS"/></a><div class="content"><a class="title" href="/2024/01/11/DS3_%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/" title="栈、队列和数组 | DS">栈、队列和数组 | DS</a><time datetime="2024-01-11T01:16:04.000Z" title="发表于 2024-01-11 09:16:04">2024-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/10/DS2_%E7%BA%BF%E6%80%A7%E8%A1%A8/" title="线性表 | DS"><img src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线性表 | DS"/></a><div class="content"><a class="title" href="/2024/01/10/DS2_%E7%BA%BF%E6%80%A7%E8%A1%A8/" title="线性表 | DS">线性表 | DS</a><time datetime="2024-01-10T01:34:05.000Z" title="发表于 2024-01-10 09:34:05">2024-01-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zero</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script src="/js/catalog.js?1"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>