<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>中央处理器 | CO | ZERO</title><meta name="keywords" content="计算机组成原理"><meta name="author" content="zero"><meta name="copyright" content="zero"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="CPU 的功能和基本结构CPU 的功能 指令控制 完成取指令、分析指令、执行指令的操作，即程序的顺序控制  操作控制 一条指令的功能往往是由若干操作信号的组合来实现的 CPU 管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作  时间控制 对各种操作加以时间上的控制 时间控制要为每条指令按时间顺序提供应有的控制信号  数据加工 对数据进行算">
<meta property="og:type" content="article">
<meta property="og:title" content="中央处理器 | CO">
<meta property="og:url" content="https://zerooo.top/2024/01/06/CO5_%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/index.html">
<meta property="og:site_name" content="ZERO">
<meta property="og:description" content="CPU 的功能和基本结构CPU 的功能 指令控制 完成取指令、分析指令、执行指令的操作，即程序的顺序控制  操作控制 一条指令的功能往往是由若干操作信号的组合来实现的 CPU 管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作  时间控制 对各种操作加以时间上的控制 时间控制要为每条指令按时间顺序提供应有的控制信号  数据加工 对数据进行算">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg">
<meta property="article:published_time" content="2024-01-06T01:37:52.000Z">
<meta property="article:modified_time" content="2024-01-09T12:59:50.040Z">
<meta property="article:author" content="zero">
<meta property="article:tag" content="计算机组成原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg"><link rel="shortcut icon" href="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/favicon.png"><link rel="canonical" href="https://zerooo.top/2024/01/06/CO5_%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '中央处理器 | CO',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-09 20:59:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/catalog.css?1"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZERO</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">中央处理器 | CO</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-06T01:37:52.000Z" title="发表于 2024-01-06 09:37:52">2024-01-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-09T12:59:50.040Z" title="更新于 2024-01-09 20:59:50">2024-01-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%80%83%E7%A0%94408/">考研408</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="中央处理器 | CO"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="CPU-的功能和基本结构"><a href="#CPU-的功能和基本结构" class="headerlink" title="CPU 的功能和基本结构"></a>CPU 的功能和基本结构</h2><h3 id="CPU-的功能"><a href="#CPU-的功能" class="headerlink" title="CPU 的功能"></a>CPU 的功能</h3><ol>
<li><p>指令控制</p>
<p>完成取指令、分析指令、执行指令的操作，即程序的顺序控制</p>
</li>
<li><p>操作控制</p>
<p>一条指令的功能往往是由若干操作信号的组合来实现的</p>
<p>CPU 管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作</p>
</li>
<li><p>时间控制</p>
<p>对各种操作加以时间上的控制</p>
<p>时间控制要为每条指令按时间顺序提供应有的控制信号</p>
</li>
<li><p>数据加工</p>
<p>对数据进行算术和逻辑运算</p>
</li>
<li><p>中断处理</p>
<p>对计算机运行过程中出现的异常情况和特殊请求进行处理</p>
</li>
</ol>
<h4 id="控制器的功能"><a href="#控制器的功能" class="headerlink" title="控制器的功能"></a>控制器的功能</h4><p>整个系统的指挥中枢</p>
<p>负责协调并控制计算机各部件执行程序的指令序列，包括取指令、分析指令、执行指令（基本功能是执行指令，执行指令就是发出有关操作控制信号）</p>
<p>在控制器的控制下，运算器、存储器和输入/输出设备等功能部件构成一个有机的整体，根据指令的要求指挥全机协调工作</p>
<h4 id="运算器的功能"><a href="#运算器的功能" class="headerlink" title="运算器的功能"></a>运算器的功能</h4><p>数据加工处理中心</p>
<p>运算器接收从控制器送来的命令并执行相应的动作，对数据进行加工和处理</p>
<h3 id="CPU-的基本结构"><a href="#CPU-的基本结构" class="headerlink" title="CPU 的基本结构"></a>CPU 的基本结构</h3><p>两大部分：运算器 + 控制器</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230727173531488.png" width="400px"/>&lt;/dev&gt;</p>
<blockquote>
<p>也可以分为 ALU、寄存器、CU、中断系统</p>
</blockquote>
<h4 id="运算器的结构"><a href="#运算器的结构" class="headerlink" title="运算器的结构"></a>运算器的结构</h4><ul>
<li><p>算术逻辑单元 ALU (Arithmetic Logic Unit)</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3398_1.png" width="350px"/>&lt;/dev&gt;</p>
<p>主要功能是进行算数/逻辑运算</p>
</li>
<li><p>通用寄存器组 GPRs (General Purpose Registers)</p>
<p>可编程指定多种功能，用于存放操作数（包括源操作数、目的操作数、中间结果）和各种地址信息等</p>
<p>本身不一定具有计数逻辑与移位逻辑</p>
<p><strong>位数与机器字长相等</strong></p>
<p>在大多数处理机中，有 8 ~ 32 个通用寄存器，在 RISC 结构的计算机中可超过 100 个</p>
<p>IA-32 中有 8 个通用寄存器：</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230727174613590.png" width="600px"/>&lt;/dev&gt;</p>
<p>为了向后兼容，EAX、EBX、ECX、EDX 的高两位字节和低两位字节可以独立使用（E 为 Extend，表示 32 位的寄存器），而低两位字节又可分别作为两个 8 位寄存器</p>
<p>BP/EBP 和 SP/ESP 分别是帧指针寄存器和栈指针寄存器，分别用来指向<strong>当前栈帧</strong>的底部和顶部</p>
<p>除 EBP 和 ESP 外，其他几个寄存器的用途比较任意</p>
</li>
<li><p>累加寄存器 ACC (Accumulator)</p>
<p>属于通用寄存器，用于暂时存放 ALU 运算的结果信息，可以作为加法运算的一个输入端（EAX 的 A 即 Accumulator）</p>
</li>
<li><p>程序状态字寄存器 PSW (Program Status Word)</p>
<p>保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如溢出标志 OF、符号标志 SF、零标志 ZF、进/借位标志 CF 等</p>
<p>这些信息参与并决定微操作的形成，比如条件转移指令执行时所依据的条件就来自 PSW</p>
</li>
<li><p>暂存寄存器</p>
<p>暂存由数据总线送来的或者说从主存读来的数据，该数据不能存放在通用寄存器中，以防破坏通用寄存器原有内容</p>
<p>对应用程序员透明</p>
<p>单总线结构下 ALU 需要配合暂存器使用：由于单总线同一时间内只能有一个操作数，且 ALU 本身内部没有存储功能的组合电路，而只有两个操作数同时出现在 ALU 的两个输入端，ALU 才能执行运算。因此需要在 ALU 的一个输入端加上暂存器，先把一个操作数暂存在暂存器中（当然两个输入端都设置一个暂存器也是可以的）。另外 ALU 的输出端也不能直接与内部总线相连，否则其输出又会通过总线反馈到输入端，影响运算结果，所以在 ALU 输出端还需要加一个暂存器</p>
</li>
<li><p>移位器</p>
<p>对操作数或运算结果进行移位运算</p>
</li>
<li><p>计数器 CT</p>
<p>控制乘除运算的操作步数</p>
</li>
</ul>
<h4 id="控制器的结构"><a href="#控制器的结构" class="headerlink" title="控制器的结构"></a>控制器的结构</h4><ul>
<li><p>程序计数器 PC (Program Counter) / 指令指针寄存器 IP (Instruction Point)</p>
<p>存放下一条指令在主存中的地址，属于寄存器</p>
<p>有自增功能（因程序中指令通常是顺序执行的）</p>
<p>位数至少为 $\log_{2}{\frac{存储器容量}{指令字长}}$</p>
</li>
<li><p>指令寄存器 IR (Instruction Register)</p>
<p>存放现行指令</p>
</li>
<li><p>存储器地址寄存器 MAR</p>
<p>用于存放要访问的主存单元的地址</p>
<p>位数和 PC 位数相等</p>
</li>
<li><p>存储器数据寄存器 MDR</p>
<p>用于存放向主存写入的信息或从主存读出的信息</p>
</li>
<li><p>指令译码器 ID (Instruction Decoder)</p>
<p>对 IR 中的操作码字段进行分析解释，产生相应的译码信号提供给微操作信号发生器</p>
</li>
<li><p>时序系统</p>
<p>用于产生各种时序信号，它们都由统一时钟（CLOCK）分频得到</p>
<p>以时钟脉冲为基础，产生不同指令对应的周期、节拍、工作脉冲等时序信号，以实现机器指令执行过程的时序控制</p>
</li>
<li><p>微操作信号发生器</p>
<p>综合时序信号、指令译码信号和执行部件反馈的条件标志（即 PSW 的内容）等，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型（硬布线控制器）和存储逻辑型（微程序控制器）两种</p>
</li>
</ul>
<hr>
<ul>
<li><p>也可以说 CPU 控制器主要由三个部件组成：PC、IR、操作控制器/控制单元 CU</p>
</li>
<li><p>一台数字计算机基本可以划分为两大部分：控制部件和执行部件。控制部件就是 CPU 的控制器，而运算器、存储器、外围设备相对控制器来说都是执行部件</p>
</li>
<li><p>CPU 内部寄存器大致可分为两类：</p>
<ol>
<li><p>用户可见的寄存器（用户可编程）</p>
<p>如 GPRs、PSW、PC、暂存寄存器</p>
</li>
<li><p>用户不可见的寄存器（用户不可编程）</p>
<p>如 MAR、MDR、IR</p>
</li>
</ol>
</li>
</ul>
<h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><ul>
<li><p>指令周期</p>
<p>CPU 从主存中取出并执行一条指令的时间，即指令执行过程</p>
</li>
<li><p>机器周期/(基本)工作周期/<strong>CPU 周期</strong></p>
<p>计算机中，常把一条指令的执行过程划分为若干个阶段，每一个阶段完成一项工作</p>
<p>每一项工作称为一个基本操作，完成一个基本操作所需要的时间称为机器周期</p>
<p>对于<strong>定长机器周期</strong>，一个机器周期通常等于一个存取周期，即把通过一次总线事务访问一次主存或 I/O 的时间定为一个机器周期。这么做是因为 CPU 内部操作的速度很快，而 CPU 访存一次时间较长</p>
</li>
<li><p>时钟脉冲信号/工作脉冲</p>
<p>控制器的最小时间单位，起定时触发作用</p>
<p>由机器脉冲源发出的脉冲信号经整形和分频后形成的</p>
<p>时钟脉冲信号的宽度称为时钟周期，时钟周期的倒数为机器主频</p>
</li>
<li><p>时钟周期/节拍/T 周期</p>
<p>计算机工作的最小时间周期，CPU 操作的最基本单位</p>
<p>时钟周期以<strong>相邻状态单元间组合逻辑电路的最大延迟</strong>为基准确定</p>
</li>
<li><p>指令周期常常用若干机器周期来表示</p>
<p>而机器周期和时钟周期不一定谁有若干个谁，只能从 <u>指令周期有几个时钟周期</u> + <u>指令周期有几个机器周期</u> 来看</p>
<p>一个指令周期一定大于等于一个时钟周期</p>
</li>
<li><p>指令周期流程</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230727203222752.png" width="700px"/>&lt;/dev&gt;</p>
<blockquote>
<p> 取指周期和执行周期是每个指令都有的工作周期（空指令？）</p>
<p> 取指周期：取指令 → PC + “1”（→ 指令译码）</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>上述 4 种工作周期都有 CPU 访存操作，但目的不同：</p>
<p>取址周期：取指令</p>
<p>间址周期：取操作数有效地址</p>
<p>执行周期：取操作数</p>
<p>中断周期：保存程序断点</p>
<blockquote>
<p>冯·诺依曼计算机根据指令周期的不同阶段来区分从存储器取出的是指令还是数据</p>
<p>控制器可区分存储单元中存放的是指令还是数据（数据通路和运算器不能）</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>为区分不同的工作周期，在 CPU 内设置了 4 个标志触发器 FE、IND、EX、INT，分别对应取指(Fetch)、间址(Indirect)、执行(Execute)、中断(Interrupt) 4 个周期(Cycle)，并以“1”状态表示有效，分别由 1 → FE、1 → IND、1 → EX、1 → INT 这 4 个信号控制</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3422_1.png" width="470px"/>&lt;/dev&gt;</p>
</li>
<li><p>每个指令周期内机器周期数可以不等</p>
<p>即不同指令的指令周期可能不同</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3418_1.png" width="700px"/>&lt;/dev&gt;</p>
</li>
<li><p>每个机器周期内的节拍数也可以不等</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3420_1.png" width="500px"/>&lt;/dev&gt;</p>
</li>
<li><p>每个执行阶段内的机器周期数也可以不等</p>
<p>比如，定长机器周期，一个机器周期取一个存取周期，而指令字长一般取存储字长的整数倍，若指令字长等于存储字长的 2 倍，则需要 2 次访存，因此取指周期等于机器周期的 2 倍</p>
<blockquote>
<p>取址周期、间址周期、执行周期、中断周期是机器周期的四种类型，但这不意味着它们的长度就为一个机器周期（虽然大多数时候是）。可以记为，一个机器周期的长度等于一个存取周期，一个执行阶段需要访存几次就需要几个机器周期（王道 P201 16）</p>
</blockquote>
</li>
<li><p>中断周期</p>
<p>当 CPU 采用中断方式实现主机和 I/O 设备的信息交换时，CPU 在每条指令执行结束前（执行周期后），都要发出中断查询信号，若有中断请求，则 CPU 进入中断响应阶段，又称中断周期</p>
</li>
</ul>
<h3 id="指令周期的数据流"><a href="#指令周期的数据流" class="headerlink" title="指令周期的数据流"></a>指令周期的数据流</h3><p>数据流：根据指令要求依次访问的数据序列</p>
<h4 id="取指周期数据流"><a href="#取指周期数据流" class="headerlink" title="取指周期数据流"></a>取指周期数据流</h4><p>根据 PC 中的内容从主存中取出指令代码并存放在 IR 中</p>
<p>不同长度的指令，其取指操作可能是不同的（访存次数可能不同）</p>
<p>以指令字长 = 存储字长的指令为例（即取指只需访存一次）：</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3432_1.png" width="500px"/>&lt;/dev&gt;</p>
<p>① ~ ③：PC 中的指令地址先送 MAR，再经地址总线送主存</p>
<p>④ ~ ⑤：CU 发出读命令经控制总线送主存</p>
<p>⑥ ~ ⑧：指令代码从主存经数据总线先送 MDR，再从 MDR 送入 IR</p>
<p>⑨：CU 发出控制信号使 PC + “1”</p>
<p>取指操作是控制器自动进行的，不需要得到相应的指令</p>
<p>若指令字长 = 存储字长，则取指周期 = 机器周期</p>
<h4 id="间址周期数据流"><a href="#间址周期数据流" class="headerlink" title="间址周期数据流"></a>间址周期数据流</h4><p>取操作数有效地址</p>
<p>具体的数据流向取决于寻址方式。以一次间址为例：</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3426_1.png" width="480px"/>&lt;/dev&gt;</p>
<p>① ~ ③：指令中的地址码  Ad(IR/MDR) 先送 MAR，再经地址总线送主存</p>
<p>④ ~ ⑤：CU 发出读命令经控制总线送主存</p>
<p>⑥ ~ ⑦：操作数有效地址从主存经数据总线送 MDR</p>
<blockquote>
<p>数据寻址，指令地址码可从 IR 或 MDR 中获取<br>因为在之前的取指周期中，指令字是先经 MDR 再送 IR，在随后的间址周期，MDR 中存放的仍是该指令字</p>
</blockquote>
<h4 id="执行周期数据流"><a href="#执行周期数据流" class="headerlink" title="执行周期数据流"></a>执行周期数据流</h4><p>取操作数，并根据 IR 中的指令字的操作码通过 ALU 操作产生执行结果</p>
<p>不同指令的执行周期操作不同，因此没有统一的数据流向</p>
<h4 id="中断周期数据流"><a href="#中断周期数据流" class="headerlink" title="中断周期数据流"></a>中断周期数据流</h4><p>处理中断请求</p>
<p>假设断点只有 PC，且保存在内存栈中，栈顶指针为 SP：</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3428_1.png" width="500px"/>&lt;/dev&gt;</p>
<p>① ~ ⑧ 保存断点（PC 值）</p>
<p>​    ① ~ ③ SP 先减 “1” 再送 MAR，然后经地址总线送主存</p>
<p>​    ④ ~ ⑤ CU 发出写命令经控制总线送主存</p>
<p>​    ⑥ ~ ⑧ PC 值先送 MDR，在由 MDR 经数据总线送存储器</p>
<p>⑨ CU 将取到的中断服务程序入口地址送 PC</p>
<blockquote>
<p>只是数据流，故没有说明关中断和引出中断服务程序入口地址的过程</p>
</blockquote>
<h3 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h3><p>多条指令的执行步骤的安排</p>
<h4 id="单指令周期"><a href="#单指令周期" class="headerlink" title="单指令周期"></a>单指令周期</h4><p>对所有指令都选用相同的执行时间来完成，每条指令都在<strong>一个时钟周期</strong>内完成</p>
<p>时钟周期取决于执行时间最长的指令的执行时间。对于那些本来可以在更短时间内完成的指令，要使用这个较长的周期来完成，会降低整个系统的运行速度</p>
<p>指令之间串行执行</p>
<h4 id="多指令周期"><a href="#多指令周期" class="headerlink" title="多指令周期"></a>多指令周期</h4><p>对不同类型的指令选用不同的执行步骤来完成</p>
<p>指令之间串行执行</p>
<p>可选用不同个数的时钟周期来完成不同指令的执行过程（需要几个就分配几个）</p>
<p>需要更复杂的硬件设计</p>
<h4 id="流水线方案"><a href="#流水线方案" class="headerlink" title="流水线方案"></a>流水线方案</h4><p>在每一个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中</p>
<p>指令之间并行执行</p>
<p>目标是力争在每个时钟周期完成一条指令的执行过程（只有理想情况下才能达到）</p>
<h2 id="数据通路的功能和基本结构"><a href="#数据通路的功能和基本结构" class="headerlink" title="数据通路的功能和基本结构"></a>数据通路的功能和基本结构</h2><h3 id="数据通路的功能"><a href="#数据通路的功能" class="headerlink" title="数据通路的功能"></a>数据通路的功能</h3><ul>
<li><p>数据通路</p>
<p>通常将指令执行过程中数据所经过的路径（包括路径上的部件）称为数据通路</p>
<p>ALU、通用寄存器、状态寄存器、Cache、异常和中断处理逻辑等都是指令执行过程中数据流经的部件，都属于数据通路的一部分</p>
<p>数据通路不包括控制部件</p>
</li>
<li><p>数据通路可分为</p>
<ol>
<li><p>CPU 内部数据通路</p>
<p>CPU 内部的数据传送通路，用于在寄存器之间或寄存器与 ALU 之间传送数据</p>
<p>宽度一般等于机器字长</p>
</li>
<li><p>CPU 外部数据通路</p>
<p>借助系统总线（数据总线），将寄存器（MAR 和 MDR）与存储器和 I/O 模块连接起来</p>
<p>宽度等于数据总线位数</p>
</li>
</ol>
</li>
<li><p>执行部件(excution unit)/功能部件(function unit)</p>
<p>数据通路中专门进行数据运算的部件</p>
</li>
<li><p>数据通路由控制部件进行控制，控制部件根据每条指令功能的不同生成对数据通路的控制信号</p>
</li>
<li><p>数据通路的功能</p>
<p>实现 CPU 内部的运算器与寄存器及寄存器之间的数据交换（内部数据通路）</p>
</li>
</ul>
<h3 id="数据通路的基本结构"><a href="#数据通路的基本结构" class="headerlink" title="数据通路的基本结构"></a>数据通路的基本结构</h3><h4 id="补充概念"><a href="#补充概念" class="headerlink" title="补充概念"></a>补充概念</h4><ul>
<li><p>指令执行所用到的元件有两类：</p>
<ol>
<li>组合逻辑元件/操作元件</li>
<li>时序逻辑元件/状态元件/存储元件</li>
</ol>
</li>
<li><p>连接元件的方式有两种：</p>
<ol>
<li>总线连接方式</li>
<li>分散连接方式</li>
</ol>
</li>
<li><p>操作元件</p>
<p>组合逻辑元件的输出只取决于当前的输入，若输入一样，其输出也一样</p>
<p>组合电路的定时<strong>不受时钟信号的控制</strong>，所有输入信号到达后，经过一定的逻辑门延迟，输出端的值被改变，并一直保持其值不变，直到输入信号改变</p>
<p>组合电路不含存储信号的记忆单元，输入和输出之间无反馈通路，信号是单向传输的</p>
<p>数据通路中常用的组合逻辑元件有多路选择器 MUX、加法器 Adder、算术逻辑部件 ALU、译码器 Decoder 等</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230728155314104.png" width="900px"/>&lt;/dev&gt;</p>
</li>
<li><p>状态元件</p>
<p>具有存储功能，输入状态<strong>在时钟控制下</strong>被写到电路中，并保持电路的输出值不变，直到下一个时钟到达</p>
<p>输入端状态由时钟决定何时被写入。在时序逻辑元件中存储的所有值仅在时钟边沿触发更新（上升沿/下降沿，双沿触发我没找到。。）</p>
<p>输出端状态随时可以读出</p>
<p>时序逻辑电路中任意时刻的输出信号不仅和当时的输入信号有关，而且与电路原来的状态有关</p>
<p>数据通路中常用的状态元件：D 触发器、寄存器、主存（外部数据通路）</p>
<blockquote>
<p>$n$ 个 D 触发器可构成一个 $n$ 位寄存器</p>
</blockquote>
</li>
</ul>
<h4 id="CPU-内部单总线方式"><a href="#CPU-内部单总线方式" class="headerlink" title="CPU 内部单总线方式"></a>CPU 内部单总线方式</h4><p>将所有寄存器的输入端和输出端都连接到一条公共通路上</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3408_1.png" width="850px"/>&lt;/dev&gt;</p>
<p>结构简单，但数据传输存在较多的冲突现象。一个时钟内只允许传一个数据，性能较低</p>
<p>CPU 中有两条或更多的总线时，构成双总线结构或多总线结构</p>
<p>各种数据传送情的流程和控制信号：</p>
<ul>
<li><p>寄存器之间数据传送（如：把 PC 内容送至 MAR）</p>
<p>(PC) → Bus    PCout 有效</p>
<p>Bus → MAR    MARin 有效</p>
<p>也可写为：(PC) → Bus → MAR 或 PC → Bus → MAR，PCout 和 MARin 有效</p>
<blockquote>
<p>Bus 指片内总线，可省略</p>
</blockquote>
</li>
<li><p>主存与 CPU 之间的数据传送（如：CPU 从主存读取指令）</p>
<p>(PC) → Bus → MAR    PCout 和 MARin 有效</p>
<p>1 → R    CU 发读命令</p>
<p>MEM(MAR) → MDR    MDRinE 有效（E = External？）</p>
<blockquote>
<p>注意这里不是经过 Bus，而是系统总线中的数据总线</p>
</blockquote>
<p>(MDR) → Bus → IR    MDRout 和 IRin 有效</p>
</li>
<li><p>执行算数或逻辑运算（以累加器型加法指令为例）</p>
<p>Ad(IR) → Bus → MAR    AdIRout 和 MARin 有效</p>
<blockquote>
<p>指令字（操作数有效地址）也可从 MDR 中取：<br>Ad(MDR) → Bus → MAR    MDRout 和 MARin 有效</p>
</blockquote>
<p>1 → R    CU 发读命令</p>
<p>MEM(MAR) → MDR    MDRinE 有效</p>
<p>(MDR) → Bus → Y    MDRout 和 Yin 有效</p>
<blockquote>
<p>Y 是暂存器。Y 的内容其连接的 ALU 输入端时钟有效</p>
</blockquote>
<p>(ACC) + (Y) → Z    ACCout 和 ALUin 有效，CU 向 ALU 发送加命令（感觉少了 Yout 有效）</p>
<blockquote>
<p>Z 也是暂存器，暂存 ALU 输出的运算结果</p>
</blockquote>
<p>(Z) → Bus → ACC    Zout 和 ACCin 有效</p>
<blockquote>
<p>可以看出，单总线结构下 ALU 需要配合暂存器使用</p>
</blockquote>
</li>
</ul>
<h4 id="CPU-内部三总线方式"><a href="#CPU-内部三总线方式" class="headerlink" title="CPU 内部三总线方式"></a>CPU 内部三总线方式</h4><p>将所有寄存器的输入端和输出端都连接到多条公共通路上</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3406_1.png" width="400px"/>&lt;/dev&gt;</p>
<p>能同时在多个总线上传送不同的数据，相较单总线方式效率有所提高</p>
<h4 id="专用数据通路方式"><a href="#专用数据通路方式" class="headerlink" title="专用数据通路方式"></a>专用数据通路方式</h4><p>根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用共享的总线</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3402_1.png" width="800px"/>&lt;/dev&gt;</p>
<p>性能较高，基本不存在数据冲突现象，但结构复杂，硬件量大，不易实现</p>
<p>专用数据通路方式下取指周期的数据传送流程和控制信号：</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3412_1.png" width="600px"/>&lt;/dev&gt;</p>
<p>(PC) → MAR    C0 有效</p>
<p>(MAR) → 主存    C1 有效</p>
<p>1 → R    控制单元向主存发送读命令</p>
<p>M(MAR) → MDR    C2 有效</p>
<p>(MDR) → IR    C3 有效</p>
<p>(PC) + 1 → PC</p>
<blockquote>
<p>最后也可以把译码算上：<br>Op(IR) → CU    C4 有效</p>
</blockquote>
<hr>
<p>数据通路结构直接影响 CPU 内各种信息的传送路径，数据通路不同，指令执行过程的微操作序列的安排也不同，它关系着微操作信号形成部件的设计</p>
<h3 id="单周期处理器"><a href="#单周期处理器" class="headerlink" title="单周期处理器"></a>单周期处理器</h3><p>单周期 CPU 中，一条指令的执行在一个时钟周期内完成（每条指令的 CPI 为 1）</p>
<p>时钟频率较低（要考虑比较慢的指令）</p>
<p>在指令执行过程中<strong>控制信号不变</strong></p>
<p><strong>不能使用单总线数据通路</strong>：单总线一个时钟周期内只允许一次数据传输，无法在一个时钟周期内完成一个指令的所有数据传输</p>
<p><strong>必须有独立的指令存储器和数据存储器</strong>：不能在一个时钟周期内对一个（单端口）存储器进行两次不同的存取（上升沿/下降沿）</p>
<p>一个简单的单周期数据通路实现：</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/1194_1.png" width="700px"/>&lt;/dev&gt;</p>
<h2 id="控制器的功能和工作原理"><a href="#控制器的功能和工作原理" class="headerlink" title="控制器的功能和工作原理"></a>控制器的功能和工作原理</h2><h3 id="控制器的结构和功能"><a href="#控制器的结构和功能" class="headerlink" title="控制器的结构和功能"></a>控制器的结构和功能</h3><ul>
<li><p>计算机硬件系统和控制器部件的组成</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3434_1.png" width="600px"/>&lt;/dev&gt;</p>
<blockquote>
<p>上图省略了 MDR 和 MAR<br>CU(SP)/PC → MAR → 地址总线，数据总线 → MDR → IR/ALU</p>
</blockquote>
</li>
<li><p>控制器的主要功能</p>
<p>指令控制、操作控制、时间控制、中断处理</p>
<ol>
<li>从主存中取出一条指令，并指出下一条指令在主存中的位置</li>
<li>对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作</li>
<li>指挥并控制 CPU、主存、输入和输出设备之间的数据流动方向</li>
</ol>
</li>
<li><p>控制器的设计</p>
<p>根据控制器产生微操作控制信号方式的不同，控制器可分为：</p>
<ol>
<li>硬布线控制器/组合逻辑控制器</li>
<li>微程序控制器</li>
</ol>
<p>两类控制器中的 PC 和 IR 是相同的，但确定和表示指令执行步骤的办法以及给出控制各部件运行所需要的控制信号的方案是不同的 </p>
</li>
</ul>
<h3 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h3><p>基本原理：根据指令的要求、当前的时序及外部和内部的状态，按时间的顺序发送一系列微操作控制信号</p>
<p>硬布线控制器由复杂的组合逻辑门电路和一些触发器构成，因此又称为组合逻辑控制器</p>
<p>特点：</p>
<ol>
<li>执行速度很快：使用纯硬件实现控制</li>
<li>扩充指令较困难：扩充一条新的指令，控制器的设计就需要大改</li>
<li>一般用于 RISC：指令越多，设计和实现就越复杂</li>
</ol>
<h4 id="硬布线控制单元图"><a href="#硬布线控制单元图" class="headerlink" title="硬布线控制单元图"></a>硬布线控制单元图</h4><p>为简化 CU 逻辑，将指令译码器和节拍发生器从 CU 分离出来：</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3436_1.png" width="800px"/>&lt;/dev&gt;</p>
<p>CU 的输入信号来源：</p>
<ol>
<li><p>经指令译码器译码产生的指令信息</p>
</li>
<li><p>时序系统产生的机器周期信号和节拍信号</p>
<p>一个时钟脉冲使控制单元发送一个操作命令或一组需要同时执行的操作命令</p>
</li>
<li><p>来自<strong>执行单元</strong>的反馈信息（不仅是 PSW）</p>
</li>
</ol>
<p>前两者是主要因素</p>
<p>另外还接收来自系统总线（控制总线）的控制信号，如中断请求、DMA 请求</p>
<h4 id="时序控制"><a href="#时序控制" class="headerlink" title="时序控制"></a>时序控制</h4><ul>
<li><p>时钟周期</p>
<p>用时钟信号控制节拍发生器，产生的每个节拍的宽度正好对应一个时钟周期</p>
<p>在每个节拍内机器可完成一个或<strong>几个需同时执行的操作</strong></p>
</li>
<li><p>机器周期</p>
<p>机器周期可视为所有指令执行过程中的一个基准时间</p>
<p>以完成最复杂指令功能的时间为准：不同指令、不同类型的机器周期的时间长短可能不同，但访问一次存储器的时间是固定的且比 CPU 中的操作时间长得多，所以通常以主存工作周期（即存取周期）作为机器周期</p>
<p>再次强调：在存储字长 = 指令字长的前提下，取指周期 = 机器周期</p>
</li>
<li><p>指令周期</p>
<p>CPU 从主存中取出并执行一条指令的时间</p>
</li>
</ul>
<h4 id="CPU-控制方式"><a href="#CPU-控制方式" class="headerlink" title="CPU 控制方式"></a>CPU 控制方式</h4><p>控制单元控制一条指令执行的过程，实质上是依次执行一个确定的微操作序列的过程</p>
<ol>
<li><p>同步控制方式</p>
<p>系统有一个统一的时钟，所有的控制信号均来自这个统一的时钟信号</p>
<p>通常以最长的微操作序列和最繁琐的微操作作为标准，采取完全统一的、具有相同时间间隔和相同数据的节拍作为机器周期来运行不同的指令</p>
<p>优点：控制电路简单</p>
<p>缺点：运行速度慢</p>
</li>
<li><p>异步控制方式</p>
<p>不存在基准时标信号，各部件按自身固有的速度工作，通过应答方式进行联络</p>
<p>优点：运行速度快</p>
<p>缺点：控制电路比较复杂</p>
</li>
<li><p>联合控制方式</p>
<p>介于同步、异步之间的一种折中，对各种不同的指令的微操作实行大部分采用同步控制、小部分采用异步控制的办法</p>
</li>
</ol>
<h4 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h4><ol>
<li><p>列出微操作命令的时间表</p>
<p>1）分析每个阶段的微操作序列（取指、间址、执行、中断），罗列出所有指令在各个阶段的微操作序列</p>
<p>2）选择 CPU 的控制方式：定长机器周期 or 不定长机器周期？每个机器周期安排几个节拍？</p>
<p>3）安排微操作时序</p>
<p>微操作的先后顺序不得随意更改</p>
<p>被控对象不同的微操作尽量安排在一个节拍内完成</p>
<p>占用时间较短的微操作尽量安排在一个节拍内完成，并允许有先后顺序</p>
<p>4）综合前几步列出微操作时间表</p>
</li>
<li><p>进行微操作信号综合</p>
<p>根据微操作时间表可写出各微操作控制信号的逻辑表达式</p>
<p>微操作命令的初始逻辑表达式，经化简、整理可获得能用现有门电路实现的微操作命令逻辑表达式</p>
<p>表达式一般包含的因素：机器周期、节拍、脉冲、操作码、机器状态条件</p>
</li>
<li><p>画出微操作命令的逻辑图（根据逻辑表达式），并用逻辑门电路实现</p>
</li>
</ol>
<h4 id="设计实例"><a href="#设计实例" class="headerlink" title="设计实例"></a>设计实例</h4><ul>
<li><p>CPU 控制方式：同步控制方式，一个机器周期安排 3 个节拍</p>
</li>
<li><p>指令各阶段的微操作序列及时序安排</p>
<ol>
<li><p>取指周期（所有指令都一样）</p>
<p>① T0  (PC) → MAR</p>
<p>② T0  1 → R                     存储器空闲即可</p>
<p>③ T1  M(MAR) → MDR   在①之后</p>
<p>④ T1  (PC) + 1 → PC       在①之后</p>
<p>⑤ T2  (MDR) → IR           在③之后</p>
<p>⑥ T2  OP(IR) → CU/ID    在⑤之后</p>
<p>从主存取数据，需独占一个节拍，在该节拍内不能有其他微操作与其存在先后执行顺序</p>
<p>⑤、⑥占时较短，可安排在一个节拍</p>
<blockquote>
<p>⑤、⑥属于指令译码，在单独写取指周期微操作命令时可省，但在写指令周期时要体现</p>
<p>注意这里的 ⑤ (MDR) → IR 与间址周期的 ④ (MDR) → Ad(IR) 的区别</p>
</blockquote>
</li>
<li><p>间址周期（以一次间接寻址为例）</p>
<p>① T0  Ad(IR) → MAR</p>
<p>② T0  1 → R</p>
<p>③ T1  M(MAR) → MDR</p>
<p>④ T2  (MDR) → Ad(IR)</p>
</li>
<li><p>执行周期（视不同指令而定）</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3438_1.png" width="700px"/>&lt;/dev&gt;</p>
<p>T0、T1 基本上是用来取数/存数。因为统一用 3 个节拍，用不了就空着，什么也不做</p>
<p>算术右移中 $AC_0 \rightarrow AC_0$ 表示 ACC 的符号位不变</p>
</li>
<li><p>中断周期（假设断点只有 PC，且保存在内存栈中，栈指针寄存器为 ESP）</p>
<p>① T0  (ESP) - 4 → ESP      入栈先改栈顶指针</p>
<p>② T0  (ESP) → MAR</p>
<p>③ T0  1 → W                     存储器空闲即可</p>
<p>④ T0  0 → EINT                硬件关中断</p>
<p>⑤ T1  (PC) → MDR           PC 值压栈，即保存断点</p>
<p>⑥ T2  (MDR) → M(MAR)</p>
<p>⑦ T2  中断向量地址 → PC</p>
</li>
</ol>
</li>
<li><p>微操作时间表</p>
<blockquote>
<p>若某指令有表中所列出的微操作命令，其对应的单元格内为 1</p>
</blockquote>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3950_1.png" width="700px"/>&lt;/dev&gt;</p>
<p>I 为间址标志。在取指周期的 T2 时刻，若 I = 1 则 IND 触发器置 “1”，标志进入间址周期，否则 EX 触发器置 “1”，标志进入执行周期</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3454_1.png" width="700px"/>&lt;/dev&gt;</p>
<p>在间址周期的 T2 时刻，若 IND = 0 则 EX 触发器置 “1”，进入执行周期，否则继续间接寻址</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3452_1.png" width="572px"/>&lt;/dev&gt;</p>
<p>在执行周期的 T2 时刻，CPU 要向所有中断源发中断查询信号，若检测到有中断请求并满足响应条件，则 INT 触发器置 “1”，标志进入中断周期</p>
<blockquote>
<p>省略了中断周期和部分指令的执行周期</p>
</blockquote>
</li>
<li><p>M(MAR) → MDR 的逻辑表达式</p>
<p>FE · T1 + IND · T1(ADD + STA + LDA + JMP + BAN) + EX · T1(ADD + LDA)<br>= T1{FE + IND(ADD + STA + LDA + JMP + BAN) + EX(ADD + LDA)}</p>
</li>
<li><p>产生 M(MAR) → MDR 的逻辑图</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3456_1.png" width="800px"/>&lt;/dev&gt;</p>
</li>
</ul>
<h3 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h3><p>设计思想：将每条机器指令编写成一个微程序，每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令。这些微程序可以存到一个控制器存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令</p>
<p>目前大多数计算机都采用微程序设计技术</p>
<h4 id="微程序控制的基本概念"><a href="#微程序控制的基本概念" class="headerlink" title="微程序控制的基本概念"></a>微程序控制的基本概念</h4><ul>
<li><p>微程序</p>
<p>一条机器指令的功能由一段微程序来实现，每一种机器指令对应一个微程序</p>
<p>微程序实际上是机器指令的实时解释器，是由计算机设计者实现编制好并存放在控制存储器中，一般不提供给用户</p>
<p>微程序的结构与功能对程序员透明</p>
</li>
<li><p>微指令</p>
<p>对机器指令执行步骤的描述</p>
<p>微程序是微指令的有序集合</p>
<p>一条微指令通常至少包括两大部分信息：</p>
<ol>
<li>操作控制字段/微操作码字段：用于产生某一步操作所需的各种操作控制信号</li>
<li>顺序控制字段/微地址码字段：用于控制产生下一条要执行的微指令地址</li>
</ol>
</li>
<li><p>微命令</p>
<p>在微程序控制的计算机中，将控制部件向执行部件发出的各种控制命令称为微命令</p>
<p>构成控制序列的最小单位</p>
<p>微指令是若干微命令的集合</p>
<p>微命令有相容性和互斥性之分：相容性微命令（可以并行完成）、互斥性微命令（不允许并行完成）</p>
</li>
<li><p>微操作</p>
<p>计算机中最基本的、不可再分解的操作</p>
<p>微操作和微命令一一对应：微命令是微操作的控制信号，微操作是微命令的执行过程</p>
</li>
<li><p>微地址</p>
<p>存放微指令的控制存储器的单元地址</p>
</li>
<li><p>微周期（微指令周期）</p>
<p>从控制存储器中读取一条微指令并执行相应的微操作所需的时间</p>
<p><strong>通常为一个时钟周期</strong></p>
</li>
</ul>
<blockquote>
<p>在组合逻辑控制器中也存在微命令和微操作这两个概念，它们并非只是微程序控制器的专有概念</p>
</blockquote>
<h4 id="微指令的编码方式-控制方式"><a href="#微指令的编码方式-控制方式" class="headerlink" title="微指令的编码方式/控制方式"></a>微指令的编码方式/控制方式</h4><p>指如何对微指令的<strong>控制字段</strong>进行编码，以形成控制信号</p>
<p>目标：在保证速度的情况下，尽量缩短指令字长</p>
<ul>
<li><p>直接编码（直接控制方式）</p>
<p>无须译码，操作控制字段的每一位代表一个微操作命令，为 “1” 时有效</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3468_1.png" width="500px"/>&lt;/dev&gt;</p>
<p>优点：简单、直观，执行速度快，操作并行性好</p>
<p>缺点：微指令字长过长，造成控存容量极大</p>
</li>
<li><p>字段直接编码方式</p>
<p>将微指令的控制字段分成若干小字段，把互斥性微命令组合在同一小字段，相容性微命令组合在不同小字段</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3470_1.png" width="350px"/>&lt;/dev&gt;</p>
<p>每个小字段独立编码，每种编码代表一个微命令，且各小字段编码含义单独定义，与其他小字段无关</p>
<p>每各小字段的信息位不能太多，否则将增加译码线路的复杂性和译码时间</p>
<p>一般每小字段还要留出一个状态，表示本字段不发出任何命令（通常用全 0）。因此当某字段的长度为 3 位时，最多只能表示 7 个互斥的微命令</p>
<p>优点：可以缩短微指令字长</p>
<p>缺点：比直接编码方式慢（因为要通过译码电路后再发出微命令）</p>
</li>
<li><p>字段间接编码方式/隐式编码</p>
<p>一个字段的某些微命令需由另一个字段中的某些微命令来解释</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3472_1.png" width="300px"/>&lt;/dev&gt;</p>
<p>由于不是靠字段直接译码发出的微命令，因此称为字段间接编码，又称隐式编码</p>
<p>优点：可进一步缩短微指令字长</p>
<p>缺点：削弱了微指令的并行控制能力，因此通常作为字段直接编码方式的一种辅助手段</p>
</li>
</ul>
<h4 id="微指令的地址形成方式"><a href="#微指令的地址形成方式" class="headerlink" title="微指令的地址形成方式"></a>微指令的地址形成方式</h4><p>后继微地址的形成主要有以下两大基本方式：</p>
<ul>
<li><p>根据机器指令的操作码形成</p>
<p>机器指令取至 IR 后，微指令的地址（对应微程序的入口地址）由操作码经微地址形成部件形成</p>
</li>
<li><p>断定方式</p>
<p>直接由微指令的下地址字段指出后继微指令地址</p>
</li>
</ul>
<p>其他方式：</p>
<ul>
<li><p>增量计数器法</p>
<p>(CMAR) + 1 → CMAR</p>
<p>适用于后继微指令地址连续的情况</p>
</li>
<li><p>分支转移</p>
<p>根据各种标志决定微指令分支转移的地址</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3474_1.png" width="350px"/>&lt;/dev&gt;</p>
</li>
</ul>
<p>  转移方式指明判别条件，转移地址指明转移成功后的去向</p>
<ul>
<li><p>通过测试网络形成</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3476_1.png" width="500px"/>&lt;/dev&gt;</p>
</li>
<li><p>由硬件直接产生微程序入口地址</p>
<p>公共微程序段的第一条微指令的地址可由专门的硬件电路产生</p>
</li>
</ul>
<h4 id="微指令的格式"><a href="#微指令的格式" class="headerlink" title="微指令的格式"></a>微指令的格式</h4><p>微指令格式与微指令编码方式有关，通常分水平型微指令和垂直型微指令两种 </p>
<ul>
<li><p>水平型微指令</p>
<p>一条微指令能定义多个可并行的微命令</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3464_1.png" width="700px"/>&lt;/dev&gt;<br>优点：微程序短，执行速度快</p>
<p>缺点：微指令长（矮胖），编写微程序较麻烦</p>
<p>从编码方式看，直接编码、字段直接编码、字段间接编码和混合编码都属于水平型微指令</p>
<blockquote>
<p>混合编码就是字段直接编码 + 字段间接编码？</p>
</blockquote>
</li>
<li><p>垂直型微指令</p>
<p>采用类似机器指令操作码的方式，在微指令中设置微操作码，采用微操作码编译法，由微操作码规定微指令的功能</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3466_1.png" width="600px"/>&lt;/dev&gt;<br>一条微指令只能定义一个微命令，由微操作码字段规定具体功能</p>
<p>优点：微指令短、简单、规整，便于编写微程序</p>
<p>缺点：微程序长（瘦长），执行速度慢，工作效率低</p>
</li>
<li><p>混合型微指令</p>
<p>在垂直型的基础上增加一些不太复杂的并行操作</p>
<p>微指令较短，仍便于编写；微程序也不长，执行速度加快</p>
</li>
</ul>
<hr>
<p>水平型微指令 vs 垂直型微指令</p>
<ol>
<li>水平型微指令并行操作能力强、效率高、灵活性强；垂直型微指令则较差</li>
<li>水平型微指令执行一条指令的时间短；垂直型微指令执行的时间长</li>
<li>由水平型微指令解释指令的微程序，具有微指令字较长但微程序短的特点；垂直型微指令则与之相反，其微指令字较短而微程序长</li>
<li>水平型微指令用户难以掌握，而垂直型微指令与机器指令比较相似，相对容易掌握</li>
</ol>
<h4 id="微程序控制器组成和工作过程"><a href="#微程序控制器组成和工作过程" class="headerlink" title="微程序控制器组成和工作过程"></a>微程序控制器组成和工作过程</h4><ul>
<li><p>微指令控制器基本结构</p>
<p>下图主要画出了微程序控制器比组合逻辑控制器多出的部件：</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230729180717629.png" width="800px"/>&lt;/dev&gt;</p>
<p><strong>控制存储器 CM</strong>：微程序控制器的核心部件，用于存放微程序，在 CPU 内部，用 ROM 实现（静态）</p>
</li>
</ul>
<p>  <strong>微地址形成部件</strong>：用于产生初始微地址和后续微地址，以保证微指令的连续执行</p>
<p>  <strong>微地址寄存器 CMAR/μPC</strong>：用于存放控制存储器的读/写微指令的地址（也叫微指令计数器？）</p>
<p>  <strong>微指令寄存器 CMDR/μIR</strong>：用于存放从控制存储器中读出的微指令</p>
<ul>
<li><p>工作过程</p>
<p>微程序控制器的工作过程实际上就是在微程序控制器的控制下计算机执行机器指令的过程</p>
<ol>
<li><p>执行取微指令公共操作</p>
<p>在机器开始运行时，自动将取指微程序入口地址送入 CMAR，并从 CM 中读出相应的微指令送入 CMDR</p>
<p>取指微程序的入口地址一般为 CM 的 0 号单元</p>
<p>当取指微程序执行完后，从主存中取出的机器指令就已存入 IR 中</p>
</li>
<li><p>由机器指令的<strong>操作码</strong>字段通过微地址形成部件产生该机器指令所对应的<strong>微程序的入口地址</strong>，并送入 CMAR</p>
</li>
<li><p>从 CM 中逐条取出对应的微指令并执行</p>
</li>
<li><p>执行完对应一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续第 1 步，以完成取下一条机器指令的公共操作</p>
</li>
</ol>
<p>以上是一条机器指令的执行过程（不包含间址周期和中断周期），如此周而复始，直到整个程序执行完毕</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3460_1.png" width="410px"/>&lt;/dev&gt;</p>
<p>所有指令的取指周期、间址周期、中断周期所对应的微指令序列都一样，可以共享使用</p>
<p>顺序逻辑根据指令地址码的寻址特征位判断是否要跳过间址周期，根据中断信号判断是否进入中断周期</p>
<p>一个微命令对应一根输出线</p>
</li>
<li><p>控制存储器中的微程序个数应为机器指令数再加上对应取指、间址和中断周期等公共的微程序数</p>
<p>如果某指令系统有 $n$ 条机器指令，则 CM 中微程序（段）的个数<strong>至少</strong>是 $n + 1$ 个，即：</p>
<p>$n$ 个 执行周期微程序（段）+ 1 个取指周期微程序（段）</p>
<blockquote>
<p>物联网设备的 CPU 和一些早期的 CPU 不提供间接寻址和中断功能，因此这类 CPU 可以不包含间址周期和中断周期的微程序段</p>
</blockquote>
</li>
</ul>
<h4 id="微程序控制单元的设计步骤"><a href="#微程序控制单元的设计步骤" class="headerlink" title="微程序控制单元的设计步骤"></a>微程序控制单元的设计步骤</h4><p>主要任务是编写各条机器指令所对应的微程序。步骤如下：</p>
<ol>
<li><p>写出对应机器指令的微操作命令及节拍</p>
<p>1）写出每个周期所需要的微操作（参照硬布线）。无论是组合逻辑设计还是微程序设计，CPU 结构相同的部分，两种控制单元的微操作命令和节拍安排都是极相似的</p>
<p>2）补充微程序控制器特有的微操作</p>
<p>① 取指周期：</p>
<p>Ad(CMDR) → CMAR（每条微指令结束之后都需要将其下地址字段送 CMAR，除了微程序最后一条微指令）</p>
<p>OP(IR) → 微地址形成部件 → CMAR（取指周期的最后一条微指令完成后，要根据指令操作码确定其执行周期微程序入口地址）</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3478_1.png" width="720px"/>&lt;/dev&gt;</p>
<p>② 执行周期：</p>
<p>Ad(CMDR) → CMAR</p>
<blockquote>
<p>Ad(CMDR) → CMAR 和 OP(IR) → 微地址形成部件 → CMAR 都要单独一个节拍</p>
</blockquote>
</li>
<li><p>确定微指令格式（微指令的编码方式、后继微指令地址的形成方式和微指令字长等）</p>
<p>根据微操作个数决定采用何种编码方式，以确定 <u>微指令操作控制字段的位数</u></p>
<p>根据 CM 中存储的微指令总数，确定 <u>微指令顺序控制字段的位数</u></p>
<p>最后按操作控制字段位数和顺序控制字段位数就可确定 <u>微指令字长</u></p>
</li>
<li><p>编写微指令码点</p>
<p>根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点（即编写操作控制字段）</p>
</li>
</ol>
<h4 id="动态微程序设计和毫微程序设计"><a href="#动态微程序设计和毫微程序设计" class="headerlink" title="动态微程序设计和毫微程序设计"></a>动态微程序设计和毫微程序设计</h4><ul>
<li><p>静态微程序设计</p>
<p>微程序无需改变，CM 采用 ROM</p>
</li>
<li><p>动态微程序设计</p>
<p>能根据用户的要求改变微程序（机器指令）</p>
<p>需要可写 CM 的支持，可以采用可擦除可编程只读存储器 EPROM</p>
</li>
<li><p>毫微程序设计</p>
<p>硬件不由微程序直接控制，而是通过存放在第二级 CM（毫微存储器）中的毫微程序来解释的</p>
<p>直接控制硬件的是毫微微指令</p>
</li>
</ul>
<h3 id="硬布线-vs-微程序"><a href="#硬布线-vs-微程序" class="headerlink" title="硬布线 vs 微程序"></a>硬布线 vs 微程序</h3><p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3480_1.png" width="600px"/>&lt;/dev&gt;</p>
<p>硬布线控制器的优点：由于控制器的速度取决于电路延迟，所以速度快</p>
<p>硬布线控制器的缺点：由于将控制部件视为专门产生固定时序控制信号的逻辑电路，所以把用最少元件和取得最高速度作为设计目标，一旦设计完成，就不可能通过其他额外修改添加新功能</p>
<p>微程序控制器的优点：同组合逻辑控制器相比，微程序控制器具有规整性、灵活性、可维护性等一系列优点</p>
<p>微程序控制器的缺点：由于微程序采用了<strong>存储程序</strong>的原理，每条微指令都要从控制存储器中取一次，影响速度</p>
<p>另外，微程序控制器的时序系统比较简单：硬布线控制器需要结合各微操作的节拍安排，综合分析，写出逻辑表达式，再设计成逻辑电路图，因此时序系统比较复杂；而微程序只需按照节拍的安排，顺序执行微指令，因此比较简单</p>
<h2 id="异常和中断机制"><a href="#异常和中断机制" class="headerlink" title="异常和中断机制"></a>异常和中断机制</h2><p>详见 OS1 <u>中断与异常</u> 和 OS5 <u>I/O 控制方式-中断驱动方式</u></p>
<h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><p><strong>流水线技术</strong>：将一个任务分解为几个不同的子阶段，每个阶段在不同的功能部件上并行执行，以便在同一时刻能够同时执行多个任务，进而提升系统性能，这种方法被称为流水线技术</p>
<p>流水线技术属于<strong>时间并行</strong>技术</p>
<p>RISC 都采用流水线技术，大部分 CISC 也采用了流水线技术</p>
<h3 id="指令流水线的基本概念"><a href="#指令流水线的基本概念" class="headerlink" title="指令流水线的基本概念"></a>指令流水线的基本概念</h3><ul>
<li><p>指令流水线</p>
<p>一条指令的执行过程可分解为若干阶段，每个阶段由相应的功能部件完成。如果将各阶段视为相应的流水段，则指令的执行过程就构成了一条指令流水线</p>
</li>
<li><p>流水线设计原则</p>
<p>指令流水段个数以最复杂指令所用的功能段个数为准</p>
<p>流水段的长度以最复杂的操作所花的时间为准</p>
</li>
<li><p>指令阶段的划分</p>
<p>假定一条指令的执行过程分为以下 5 个阶段/功能段/流水段</p>
<ol>
<li>取指 IF：从指令存储器或 Cache 中取指令</li>
<li>译码/读寄存器 ID：操作控制器对指令进行译码，同时从寄存器堆中取操作数</li>
<li>执行/计算地址 EX：执行运算操作或计算地址</li>
<li>访存 MEM：对数据存储器或 Cache 进行读写操作</li>
<li>写回 WB：将指令执行结果写回寄存器堆</li>
</ol>
<blockquote>
<p>如何划分指令的执行过程，不同的教材有不同的划分方式，这里参考了历年统考真题中的划分</p>
</blockquote>
</li>
<li><p>流水段的长度</p>
<p>主要功能单元的操作时间假设如下：</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3522_1.png" width="600px"/>&lt;/dev&gt;</p>
<p>单周期处理器中，需要延伸时钟周期至 800ps 以满足最慢的指令 LDUR</p>
<p>而在流水线中，<strong>每个流水段都需要一个时钟周期</strong>。因此按照流水线设计原则，每个流水段长度（时钟周期）为 200ps（还应加上锁存器延时时间）</p>
<p><strong>流水线方式并不能缩短单条指令的执行时间</strong>，但对整个程序来说，执行效率得到了大幅提高</p>
</li>
<li><p>指令流水线的执行方式</p>
<p>把 $k + 1$ 条指令的取指阶段提前到第 k 条指令的译码阶段，从而将第 $k + 1$ 条指令的译码阶段与第 $k$ 条指令的执行阶段同时进行</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230730175332153.png" width="600px"/>&lt;/dev&gt;</p>
<p>理想情况下，每个时钟周期都有一条指令进入流水线，每个时钟周期都有一条指令完成，每条指令的时钟周期数（即 CPI）都为 1</p>
<p>优点：各部件的利用率明显提高</p>
<p>缺点：硬件开销较大，控制过程也更复杂</p>
</li>
<li><p>有利于实现指令流水线的指令集的特征</p>
<ol>
<li><p>指令长度尽量一致</p>
<p>有利于简化取指和指令译码操作，否则取指耗时不一，使取指部件机器复杂，也不利于指令译码</p>
</li>
<li><p>指令格式尽量规整</p>
<p>尽量保证源寄存器的位置相同，有利于在指令未知时（指令译码前）就可取寄存器操作数</p>
</li>
<li><p>采用 Load/Store 指令，其他指令都不能访问存储器</p>
<p>这样可把 Load/Store 指令的地址计算和运算指令的执行步骤规整在同一个周期中，有利于减少操作步骤</p>
</li>
<li><p>数据和指令在存储器中“对齐”存放</p>
<p>有利于减少访存次数，使所需数据在一个流水段内就能从存储器中得到</p>
</li>
</ol>
</li>
<li><p>流水线的表示方法</p>
<ol>
<li><p>指令执行过程图</p>
<p>主要用于分析指令执行过程以及影响流水线的因素</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3490_1.png" width="700px"/>&lt;/dev&gt;</p>
</li>
<li><p>时空图</p>
<p>主要用于分析流水线的性能</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230731094550324.png" width="600px"/>&lt;/dev&gt;</p>
<p>空间：不同阶段所对应的不同的硬件资源</p>
<p>装入时间：第一个任务进入流水线到输出流水线的时间</p>
<p>排空时间：最后一个任务进入流水线到输出流水线的时间</p>
<p>只有大量连续任务不断输入流水线，才能充分发挥流水线的性能</p>
</li>
</ol>
</li>
<li><p>流水线的分类*</p>
<p>按流水线使用级别的不同</p>
<ol>
<li><p>部件功能级流水线</p>
<p>将复杂的算术逻辑运算组成流水线工作方式</p>
</li>
<li><p>处理机级流水线</p>
<p>把一条指令解释过程分成多个子过程</p>
</li>
<li><p>处理机间级流水线</p>
<p>一种宏流水，其中每一个处理机完成某一专门任务，各个处理机所得到的结果需存放在与下一个处理机所共享的存储器中</p>
</li>
</ol>
<p>按可以完成的功能</p>
<ol>
<li><p>单功能流水线</p>
<p>只能实现一种固定的专门功能的流水线</p>
</li>
<li><p>多功能流水线</p>
<p>通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线</p>
</li>
</ol>
<p>按同一时间各段之间的连接方式</p>
<ol>
<li><p>静态流水线</p>
<p>上下段连接方式固定</p>
<p>在同一时间内，流水线的各段只能按同一种功能的连接方式工作</p>
</li>
<li><p>动态流水线</p>
<p>上下段连接方式不固定</p>
<p>在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算</p>
<p>这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂</p>
</li>
</ol>
<p>按流水线的各功能段间是否有反馈信号</p>
<ol>
<li><p>线性流水线</p>
<p>从输入到输出，每个功能段只允许经过一次，不存在反馈回路</p>
</li>
<li><p>非线性流水线</p>
<p>存在反馈回路，从输入到输出过程中，某些功能段将数次通过流水线</p>
<p>这种流水线适合进行线性递归的运算</p>
</li>
</ol>
</li>
</ul>
<h3 id="流水线的基本实现"><a href="#流水线的基本实现" class="headerlink" title="流水线的基本实现"></a>流水线的基本实现</h3><p>基于 MIPS ISA，字节编址，采用 32 位定长指令字</p>
<p>MIPS 指令格式：</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230731130456222.png" width="560px"/>&lt;/dev&gt;</p>
<p>R 型指令为寄存器-寄存器操作，I 型为 16 位立即数操作，J 型为无条件转移指令</p>
<p>R 型指令 31:26 操作码字段全 0，使用 5:0 funct 字段区分指令</p>
<p>五段流水线数据通路实现概览：</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230731095630359.png" width="900px"/>&lt;/dev&gt;</p>
<p>虚线表示控制信号</p>
<h4 id="所需部件"><a href="#所需部件" class="headerlink" title="所需部件"></a>所需部件</h4><p>IF 段：PC、指令存储器（只读，可视为组合逻辑）、加法器（PC + 4）、多路选择器 MUX（控制写入 PC 的值是 PC + 4 还是分支目标地址）</p>
<p>ID 段：控制器、寄存器堆、符号扩展单元（将指令中的立即数字段符号扩展为 32 位）、多路选择器 MUX（控制写入目的寄存器编号选择 rt 还是 rd）</p>
<p>EX 段：ALU、加法器（计算分支目标地址）、多路选择器 MUX（控制 ALU 的第二输入选自寄存器 rt 还是立即数符号扩展的值）</p>
<blockquote>
<p>MIPS 规定分支地址计算时使用的基址是 PC + 4，规定偏移量左移 2 位（PC 相对寻址中的地址设计成字地址）<br>由于移位数量固定，符号扩展后的左移操作不需要真正的移位电路</p>
</blockquote>
<p>MEM 段：数据存储器</p>
<p>WB 段：多路选择器 MUX（控制是将 ALU 运算结果还是数据存储器读出数据写回寄存器堆）</p>
<hr>
<p>除写回段外，流水线每一个功能段部件后面都要有一个<strong>流水寄存器/锁存器</strong>，根据其所连接的功能段来命名（IF/ID、ID/EX、EX/MEM、MEM/WB）。其作用是保存本段处理完成的数据和控制信号，以保证本段的执行结果能在下个时钟周期提供给下一流水段使用</p>
<p>不同流水寄存器锁存的数据：</p>
<ul>
<li><p>IF/ID 锁存器：从指令存储器取出的指令字、PC + 4</p>
</li>
<li><p>ID/EX 锁存器：控制信号、从寄存器堆中取出的两个操作数 RS 和 RT、写寄存器编号 WriteReg#、立即数符号扩展的值、PC + 4</p>
</li>
<li><p>EX/MEM：控制信号、ALU 运算结果、待写入数据存储器数据 WriteData、写寄存器编号 WriteReg#</p>
</li>
<li><p>MEM/WB：控制信号、ALU 运算结果、数据存储器读出数据、写寄存器编号 WriteReg#</p>
</li>
</ul>
<p>综上，流水寄存器保存的信息包括：</p>
<ul>
<li>后面流水段需要用到的所有数据信息，包括 PC + 4、指令、立即数、目的寄存器、ALU 运算结果、标志信息等</li>
<li>前面传递过来的后面各流水段要用到的所有控制信号</li>
</ul>
<blockquote>
<p>PC 可视为流水寄存器：给流水线的 IF 段提供数据。但 PC 是可见体系结构状态的一部分，发生异常时其内容必须被保存下来，而流水寄存器的内容可被丢弃</p>
</blockquote>
<h4 id="控制信号"><a href="#控制信号" class="headerlink" title="控制信号"></a>控制信号</h4><p>主要的控制信号：</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230731125300861.png" width="900px"/>&lt;/dev&gt;</p>
<blockquote>
<p>还漏了一个条件分支译码信号 Branch，由 ID 段控制器译码产生，经 ID/EX 流水寄存器传递至 EX 段，与 ALU 运算的标志 equal 信号进行逻辑与操作后，反馈到 IF 段控制多路选择器进行分支处理</p>
</blockquote>
<p>除了 BranchTaken 信号外，以上 7 个控制信号均由控制器通过指令的操作码字段译码直接产生的</p>
<h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>所有指令都需要完整经过流水线的各功能段，即使在某些功能段内没有实质性的操作</p>
<p>本条指令 $I_1$ 进入 IF 段：</p>
<p><strong>取指 IF</strong></p>
<ul>
<li><p>将 PC 值作为地址从指令存储器中取出指令字</p>
</li>
<li><p>计算 PC + 4，并送入多路选择器的一个输入段</p>
</li>
<li>多路选择器根据之前指令 EX 段传来的 BranchTaken 信号和分支地址 BranchAddr，从 BranchAddr 和 PC + 4 中选择一个送入 PC 的输入端</li>
<li>时钟到来时将 PC + 4 和指令字锁存到 IF/ID 流水寄存器</li>
</ul>
<p>本条指令 $I_1$ 进入 ID 段，下条指令进入 $I_2$ 进入 IF 段</p>
<p><strong>译码/读寄存器 ID</strong></p>
<ul>
<li><p>控制器根据 IF/ID 流水寄存器中的指令字生成后续各段需要的控制信号</p>
</li>
<li><p>对于 lw 访存指令，根据指令字中的 rs、rt 取出寄存器堆中的值 RS 和 RT</p>
</li>
<li><p>多路选择器根据指令字和 RegDst 信号生成可能的写寄存器编号 WriteReg#</p>
</li>
<li><p>符号扩展单元将指令字中的 16 位立即数符号扩展为 32 位</p>
</li>
<li><p>时钟到来时将这些数据和 6 个控制信号（除 RegDst 信号）连同 PC + 4 锁存到 ID/EX 流水寄存器中</p>
</li>
</ul>
<p>本条指令 $I_1$ 进入 EX 段，下条指令进入 $I_2$ 进入 ID 段，下下条指令 $I_3$ 进入 IF 段</p>
<p><strong>执行/计算地址 EX</strong></p>
<p>EX 段功能由具体指令指定</p>
<ul>
<li><p>对于 lw 指令，EX 主要用来计算访存地址：将 ID/EX 流水寄存器中的 RS 值与符号扩展后的立即数得到访存地址</p>
</li>
<li><p>可能需要计算分支地址：</p>
<p>将符号扩展后的立即数（偏移量）左移 2 位与 PC + 4（作为基址）相加得到分支地址 BranchAddr</p>
<p>ID/EX 流水寄存器中的 Branch 信号与 ALU 运算的标志 equal 信号相与生成分支转跳信号 BranchTaken</p>
<p>BranchAddr 和 BranchTaken 送 IF 段的多路选择器</p>
</li>
<li><p>时钟到来时</p>
<ol>
<li>将 ① ALU 运算结果、② ID/EX 流水寄存器中的写寄存器编号 WriteReg#、③ ID/EX 流水寄存器中的 RT 值（可能会在 MEM 段作为写入数据 WriteData 使用）、③ 后段需要的控制信号（MemWrite、MemToReg、RegWrite）锁存到 EX/MEM 流水寄存器</li>
<li>更新 PC 值</li>
</ol>
</li>
</ul>
<p>本条指令 $I_1$ 进入 MEM 段，后续指令 $I_2$、$I_3$、$I_4$ 分别进入 EX、ID、IF 段</p>
<p><strong>访存 MEM</strong></p>
<p>MEM 段功能也由具体指令指定</p>
<ul>
<li>对于 lw 指令，主要是根据 EX/MEM 流水寄存器中的 ALU 计算出的访存地址、WriteData 以及 Mem Write 信号对数据存储器进行读/写操作</li>
<li>时钟到来时：<ol>
<li>WriteData 写入数据存储器（不一定）</li>
<li>将 ① EX/MEM 流水寄存器中的 ALU 运算结果、② 数据存储器读出的数据（不一定）、③ EX/MEM 流水寄存器中的写寄存器编号 WriteReg#、④ 后段需要的控制信号（MemToReg、RegWrite）锁存到 MEM/WB 流水寄存器</li>
</ol>
</li>
</ul>
<p>本条指令 $I_1$ 进入 WB 段，后续指令 $I_2$、$I_3$、$I_4$、$I_5$ 分别进入 MEM、EX、ID、IF 段</p>
<p><strong>写回 WB</strong></p>
<p>WB 段功能也由具体指令指定</p>
<ul>
<li>多路选择器根据 MEM/WB 流水寄存器中的 MemToReg 信号，从同样来自 MEM/WB 流水寄存器的 ALU 运算结果和数据存储器读出的数据中，选择一个作为写回数据 WriteBackData，连同 MEM/WB 流水寄存器中的 WriteReg#，送寄存器堆</li>
<li>时钟到来时完成数据写回指定的寄存器（不一定）</li>
</ul>
<p>本条指令 $I_1$ 执行结束，后续指令 $I_2$、$I_3$、$I_4$、$I_5$、$I_6$ 分别进入 WB、MEM、EX、ID、IF 段</p>
<h3 id="流水线的冒险与处理"><a href="#流水线的冒险与处理" class="headerlink" title="流水线的冒险与处理"></a>流水线的冒险与处理</h3><p>在指令流水线中，可能会遇到一些情况使得流水线无法正确执行后续指令而引起流水线阻塞或停顿，这种现象称为<strong>流水线冒险</strong>(hazard)</p>
<p>根据导致冒险的原因可分为：结构冒险、数据冒险、控制冒险</p>
<blockquote>
<p>除了流水线冒险，Cache 缺失的处理过程也会引起流水线阻塞</p>
</blockquote>
<h4 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h4><p>结构冒险(structural hazard) / 硬件资源冲突(hardware resource confict)，由于多条指令在同一时刻争用同一资源而形成的冲突，即由硬件资源竞争造成的冲突</p>
<p>解决办法：</p>
<ol>
<li><p>后一相关指令（及其后续指令）暂停一个时钟周期</p>
</li>
<li><p>资源重复配置。如单独设置数据存储器和指令存储器，使取数和取指令操作各自在不同的存储器中进行</p>
<p>事实上，现代计算机都引入了 Cache 机制，而 L1 Cache 通常采用数据 Cache 和指令 Cache 分离的方式，因而也就避免了资源冲突的发生</p>
</li>
</ol>
<h4 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h4><p>数据冒险(data hazard) / 数据相关(data dependency)，在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3498_1.png" width="720px"/>&lt;/dev&gt;</p>
<blockquote>
<p>图示指令格式：<br>R 型：操作码  目的寄存器,  源操作数寄存器1,  源操作数寄存器2<br>D 型：操作码  目的寄存器/要写的数据,  [基址寄存器, 偏移量]</p>
</blockquote>
<p>时间轴上倒退的线会产生数据冒险。设存在访问寄存器操作的流水段是第 $m$、$n$ 段（$m &lt; n$），会发生数据冒险的范围是：某指令在 $n$ 段访问了寄存器 R，则该指令随后的 $n - m$ 条指令，若其第 $m$ 段也访问了寄存器 R，则会发生数据冒险（除去 RAR 相关）</p>
<blockquote>
<p>在一个时钟周期内同时读写一个寄存器不会产生数据冒险：通过硬件设计，大部分寄存器文件在时钟周期的前半部分写，后半部分读</p>
</blockquote>
<p>数据冒险可分为三类：</p>
<ol>
<li><p>写后读 RAW (Read After Write) 相关</p>
<p>当前指令将数据写入寄存器后，下一条指令才能从该寄存器读取数据，否则就会读到错误数据（旧数据）</p>
</li>
<li><p>读后写 WAR (Write After Read) 相关</p>
<p>当前指令读出数据后，下一条指令指令才能写该寄存器，否则就会读到错误数据（新数据）</p>
</li>
<li><p>写后写 WAW (Write After Write) 相关</p>
<p>当前指令写入寄存器后，下一条指令才能写该寄存器，否则该寄存器的值不是正确的最新值</p>
</li>
</ol>
<p>指令按序发射按序完成时（或者说按序流动的流水线），只可能出现 RAW 相关。在非按序流动的流水线中，RAW 相关、WAR 相关、WAW 相关都有可能发生</p>
<blockquote>
<p>指令发射指的是指令从译码阶段进入执行阶段</p>
<p>读后读 RAR (Read After Read) 相关，当两条连续的指令读取相同的寄存器时会产生。这种相关不会影响流水线</p>
</blockquote>
<p>解决办法：</p>
<ol>
<li><p>数据旁路(bypassing)/前推(forwarding)技术</p>
<p>从内部缓冲中提前获取缺失的数据，而非等到从程序员可见的寄存器或存储器中取出数据</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3500_1.png" width="720px"/>&lt;/dev&gt;</p>
</li>
<li><p>把遇到数据冒险的指令及其后续指令都暂停一至几个时钟周期，直到数据冒险消失后再继续执行</p>
<p>可分为：</p>
<p>1）软件插入 NOP（插入空指令）</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3502_1.png" width="720px"/>&lt;/dev&gt;</p>
<p>上图中，当 AND 指令处于 ID 级（CC 3）时，将 EX、MEM 和 WB 级控制信号都为无效，可使得 AND 指令变成 nop 指令（即空操作指令，除修改 PC 外其他什么操作也不做）</p>
<p>处于 ID 级的指令被阻塞，那处于 IF 级的指令也必须被阻塞，否则取到的指令会丢失（会覆盖 IF/ID 锁存器）。防止这两条指令继续执行的方法是：保持 PC 和 IF/ID 锁存器不变</p>
<p>实际的效果是拉长了指令 AND 和 ORR 的时间：强迫 AND 指令和 ORR 指令在 CC 4 重复 CC 3 的操作，并延迟了最后一个 ADD 指令的取指</p>
<p>2）硬件阻塞(stall)/气泡(bubble)</p>
<p>为解决取数-使用型数据冒险而实施的一种阻塞。在采取旁路之前，流水线必须进行阻塞</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3504_1.png" width="600px"/>&lt;/dev&gt;</p>
</li>
<li><p>编译优化</p>
<p>通过编译器对数据相关的指令编译优化的方法，<strong>调整指令顺序</strong>来解决数据相关</p>
<p>效果不好，因为数据相关经常发生，延迟过长</p>
</li>
</ol>
<h4 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h4><p>当前要执行哪条指令是由之前转移指令或其他改变 PC 值的指令的运行结果决定，但现在那条指令的结果还没产生，使得流水线断流，这就导致了<strong>控制冒险</strong>(control hazard)</p>
<p>解决办法：</p>
<ol>
<li><p>对转移指令进行分支预测</p>
<p>尽早判别转移是否发生，尽早生成转移目标地址</p>
<p>1）简单（静态）预测</p>
<p>总是预测条件不满足，即继续执行分支指令的后续指令</p>
<p>2）动态预测</p>
<p>根据程序执行的历史情况，进行动态预测调整</p>
</li>
</ol>
<p>   当预测错误时（分支指令到达 MEM 级时才能决定），流水线控制必须确保预测错误的分支后面的指令执行不会产生实际效果，已经取出并译码的指令必须丢弃（丢弃指令意味着必须将流水线 IF、ID 和 EX 级中的指令都清空），并且必须从正确的分支地址处重新启动流水线</p>
<ol>
<li><p>预取转移成功和不成功两个控制流方向上的目标指令</p>
</li>
<li><p>加快和提前形成条件码/减少分支延迟</p>
<p>将分支决策提前（到 ID 级）。越早开始条件分支的执行，则需要清空的指令就越少</p>
<p>需要提前两个动作到 ID 级：</p>
<p>① 计算分支目标地址：只需将计算分支地址的加法器从 EX 级移到 ID 级</p>
<p>② 判断分支条件：比较复杂，需要额外的旁路和冒险检测硬件，因为分支条件的判断可能依赖于还在流水线中的结果</p>
<p>尽管有些困难，但将分支执行提前到 ID 级依然是一种有效的改进，因为它将分支发生时预测错误的代价减小到只有一条指令</p>
</li>
<li><p>延迟分支(delayed branch)</p>
<p>即<strong>调整指令的顺序</strong>，将一定会执行的指令放在分支指令后面（不受该分支影响的指令），这样流水线不停顿。但要注意不能改变这段代码原来的意义</p>
</li>
<li><p>取出分支指令后立即<strong>阻塞</strong>流水线（NOP 或 bubble）</p>
<p>虽然流水线阻塞能用来解决各种冒险，但要尽量避免，因为它的效率低下：</p>
<p>1）在较长的流水线中往往不能在第二级就解决分支问题（这意味着要在分支指令后添加多个周期的气泡）</p>
<p>2）条件分支指令是很常用的指令</p>
</li>
</ol>
<hr>
<p>对流水线影响最严重的指令相关是数据相关</p>
<p>对现代流水线而言：</p>
<ol>
<li>结构冒险经常出现在浮点单元附近，因为浮点单元通常不能完全流水化</li>
<li>控制冒险更多地出现在整数程序中，因为整数程序中条件分支和预测的分支出现的频率更高</li>
<li>数据冒险在整数和浮点程序中都可能成为性能瓶颈</li>
<li>浮点程序中的数据冒险更容易处理，因为条件分支出现的频率更低，并且更多规则的存储器访问使得编译器能够尝试调度指令以避免冒险</li>
<li>整数程序中涉及大量的指针，规则的存储器访问更少，因此编译器优化就要困难一些</li>
</ol>
<h3 id="流水线的性能指标"><a href="#流水线的性能指标" class="headerlink" title="流水线的性能指标"></a>流水线的性能指标</h3><p>理想情况：指令各阶段花费时间相同；每个阶段结束后能立即进入下一阶段</p>
<p>目标：要在不过多增加硬件成本的情况下，尽可能地提高指令流水线的运行效率</p>
<h4 id="吞吐率-TP"><a href="#吞吐率-TP" class="headerlink" title="吞吐率 TP"></a>吞吐率 TP</h4><p>单位时间内流水线所完成的任务数量或输出结果的数量</p>
<p>基本公式：TP = $\frac{n}{T_k}$（$n$ 是任务数，$T_k$ 是处理完 $n$ 个任务所用时间）</p>
<p>$k$ 级流水线：</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3494_1.png" width="500px"/>&lt;/dev&gt;</p>
<p>该流水线的实际吞吐率 TP = $\frac{n}{(k+n-1)\Delta t}$，当 $n$ → ∞ 时，得最大吞吐率 $TP_{max}$ = 1/Δt</p>
<h4 id="加速比-S"><a href="#加速比-S" class="headerlink" title="加速比 S"></a>加速比 S</h4><p>完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比</p>
<p>基本公式：$S$ = $\frac{T_0}{T_k}$（$T_0$ 表示不使用流水线时，即顺序执行，所用的时间）</p>
<p>$k$ 级流水线的实际加速比 $S$ = $\frac{kn \Delta t}{(k+n-1) \Delta t}$ = $\frac{kn}{k+n-1}$，当 $n \rightarrow \infin$ 时，得最大加速比 $S_{max}$ = $k$</p>
<h4 id="效率-E"><a href="#效率-E" class="headerlink" title="效率 E"></a>效率 E</h4><p>流水线的设备利用率</p>
<p>在时空图上，流水线的效率定义为：$E$ = $\frac{完成 n 个任务占用的时空区有效面积}{n 个任务所用的时间与 k 个流水段所围成的时空区总面积}$ = $\frac{kT_k-k(k-1)\Delta t}{kT_k}$</p>
<p>当 $n \rightarrow \infin$ 时，得最高效率为 1</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3496_1.png" width="600px"/>&lt;/dev&gt;</p>
<p>可以看出，流水线的效率包含了时间和空间两个因素</p>
<hr>
<p>流水段越多，指令执行不一定越快：</p>
<ol>
<li><p>流水段缓冲之间的额外开销增大</p>
<p>特别是当指令间逻辑上相互依赖时。这些开销加长了一条指令的整个执行时间</p>
</li>
<li><p>流水段间控制逻辑变多、变复杂</p>
<p>用于流水线优化和存储器或寄存器冲突处理的控制逻辑将随流水段的增大而大增，这可能导致用于流水段之间控制的逻辑比段本身的控制逻辑更复杂</p>
</li>
</ol>
<p>但流水线越多并行度越高是真的</p>
<h3 id="高级流水线技术"><a href="#高级流水线技术" class="headerlink" title="高级流水线技术"></a>高级流水线技术</h3><h4 id="超标量流水线技术"><a href="#超标量流水线技术" class="headerlink" title="超标量流水线技术"></a>超标量流水线技术</h4><p>也称动态多发射技术，每个时钟周期内可并发多条独立指令，以并行操作方式将两条或多条指令编译并执行（有一条以上的流水线）</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3508_1.png" width="450px"/>&lt;/dev&gt;</p>
<p>需配置多个功能部件，以空间换时间</p>
<p>简单的超标量 CPU 中，指令按序发射执行。多数超标量 CPU 都<strong>结合动态流水线调度技术</strong>，通过动态分支预测等手段，指令乱序执行，以挖掘更多的指令并行性</p>
<h4 id="超流水线技术"><a href="#超流水线技术" class="headerlink" title="超流水线技术"></a>超流水线技术</h4><p>通过提高流水线主频的方式来提升流水线性能</p>
<p>流水线功能段划分得越多，时钟周期就越短（一个小功能段总是占一个时钟周期），指令吞吐量也就越高</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3510_1.png" width="525px"/>&lt;/dev&gt;</p>
<p>但流水线级数越多，用于流水寄存器的开销就越大，因而流水线级数是有限制的，并不是越多越好</p>
<p>超流水线 CPU 在流水线充满后，每个时钟周期还是执行一条指令，CPI = 1，但其主频更高</p>
<h4 id="超长指令字"><a href="#超长指令字" class="headerlink" title="超长指令字"></a>超长指令字</h4><p>也称静态多发射技术，由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字（可达几百位）</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/3512_1.png" width="475px"/>&lt;/dev&gt;</p>
<p>需采用多个处理部件</p>
<p>对 Cache 的容量要求更大</p>
<h2 id="多处理器的基本概念"><a href="#多处理器的基本概念" class="headerlink" title="多处理器的基本概念"></a>多处理器的基本概念</h2><h3 id="SISD、SIMD、MIMD"><a href="#SISD、SIMD、MIMD" class="headerlink" title="SISD、SIMD、MIMD"></a>SISD、SIMD、MIMD</h3><p>基于指令流的数量和数据流的数量，将计算机体系结构分为 SISD、SIMD、MISD、MIMD 四类</p>
<p>常规的单处理器属于 SISD，常规的多处理器属于 MIMD</p>
<ul>
<li><p>单指令流单数据流 SISD 结构</p>
<p>传统的串行计算机结构</p>
<p>通常仅包含一个处理器和存储器，处理器在一段时间内仅执行一条指令</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230731210138771.png" width="400px"/>&lt;/dev&gt;</p>
<p>为提高速度，有些 SISD 计算机采用流水线 CPU 和多体交叉编址存储器</p>
</li>
<li><p>单指令流多数据流 SIMD 结构</p>
<p>一个指令流同时对多个数据流进行处理，一般称为数据级并行技术</p>
<p>通常由一个指令控制部件、多个处理单元组成</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230731210350539.png" width="450px"/>&lt;/dev&gt;</p>
<p>虽然不同处理单元执行的是同一条指令，但它们处理的数据是不同的</p>
<p>对结构类似的大量数据进行相同处理，一条指令处理很多条数据</p>
<p>一个顺序应用程序被编译后，可能按 SISD 组织并运行于串行硬件上，也可能按 SIMD 组织并运行于并行硬件上</p>
<p>可用于优化  for 循环中对数组元素的重复处理</p>
<p>某些显卡在图像处理时，常采用 SIMD 对每个像素点进行完全一样的渲染（如加滤镜）</p>
</li>
<li><p>多指令流单数据流 MISD 结构</p>
<p>同时执行多条指令，处理同一个数据，实际上不存在</p>
</li>
<li><p>多指令流多数据流 MIMD 结构</p>
<p>同时执行多条指令分别处理多个不同的数据</p>
<p>分为：</p>
<ol>
<li><p>多处理器系统</p>
<p>多处理器系统是共享存储多处理器 SMP 系统的简称，也称共享存储 MIMD</p>
<p>具有共享的单一地址空间，通过存取指令来访问系统中的所有存储器</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230731212154488.png" width="800px"/>&lt;/dev&gt;</p>
</li>
<li><p>多计算机系统</p>
<p>多台计算机组成的分布式计算系统，通过消息传递进行数据传送</p>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230731211310856.png" width="700px"/>&lt;/dev&gt;</p>
</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li><p>SIMD 和 MIMD 是两种并行计算模式</p>
<p>SIMD 是一种数据级并行模式，而 MIMD 是一种并行程度更高的线程级并行或线程级以上并行计算模式</p>
</li>
<li><p>向量处理器</p>
<p>SIMD 的变体，是一种实现了直接操作一维数组（向量）指令集的 CPU</p>
<p>其基本理念是将从存储器中收集的一组数据按顺序放到一组向量寄存器中，然后以流水化的方式对它们依次操作，最后将结果写回寄存器</p>
<p>向量处理器在特定工作环境中极大地提升了性能，尤其是在数值模拟或相似的领域中</p>
</li>
</ul>
<h3 id="硬件多线程"><a href="#硬件多线程" class="headerlink" title="硬件多线程"></a>硬件多线程</h3><p>目的：减少线程切换中的开销</p>
<p>为每个线程提供单独的通用寄存器组、单独的程序计数器等，线程切换只需激活选中的寄存器，从而省略了与存储器数据交换的环节</p>
<p>仅复制必要的线程资源，共享 CPU 的高速缓存和功能部件，以单核模拟多核</p>
<p>需要芯片组、操作系统、应用软件的支持</p>
<p>硬件多线程有 3 种实现方式：细粒度多线程、粗粒度多线程、同时多线程 SMT</p>
<ul>
<li><p>细粒度多线程</p>
<p>多个线程之间轮流交叉执行指令，多个线程之间的指令是不相关的，可以乱序并行执行</p>
</li>
<li><p>粗粒度多线程</p>
<p>仅在一个线程出现了较大开销的阻塞时（如 Cache 缺失），才切换线程</p>
<p>当发生流水线阻塞时，必须清除被阻塞的流水线，新线程的指令开始执行前需重载流水线</p>
<p>开销比细粒度多线程大</p>
</li>
<li><p>同时多线程 SMT</p>
<p>是上述两种多线程技术的变体</p>
<p>在实现指令级并行的同时，实现线程级并行。也就是说，它在同一个时钟周期中，发射不同线程中的多条指令执行</p>
<blockquote>
<p>Intel 处理器中的超线程(Hyper-threading)就是同时多线程 SMT<br>即在一个单处理器或单个核中设置了两套线程状态部件，共享高速缓存和功能部件</p>
</blockquote>
</li>
</ul>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230731233008561.png" width="750px"/>&lt;/dev&gt;</p>
<h3 id="多核处理器"><a href="#多核处理器" class="headerlink" title="多核处理器"></a>多核处理器</h3><p>指将多个处理单元集成到单个 CPU 中，每个处理单元称为一个核(core)</p>
<p>每个核可以有自己的 Cache，也可以共享一个 Cache</p>
<p>所有核通常是对称的，且共享主存储器，因此多核属于共享存储的对称多处理器</p>
<blockquote>
<p>因为多核 CPU 的各核心通常都是对称的，因此 2.4GHz 双核 CPU 中两个核的主频也是 2.4GHz</p>
</blockquote>
<p><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230731233842494.png" width="350px"/>&lt;/dev&gt;</p>
<p>采用多核 CPU 可以降低计算机系统的功耗（相较于提高主频）和体积（相较于多个处理器）</p>
<p>一般采用偶数路 CPU</p>
<h3 id="共享内存多处理器"><a href="#共享内存多处理器" class="headerlink" title="共享内存多处理器"></a>共享内存多处理器</h3><p>具有共享的单一物理地址空间的多处理器被称为共享内存多处理器 SMP</p>
<p>处理器通过存储器中的共享变量互相通信</p>
<p>所有处理器都能通过存取指令访问存储器的任何位置</p>
<p>每个处理器仍可在自己的虚拟地址空间中单独地运行程序</p>
<p>有两种类型：</p>
<ul>
<li><p>统一存储访问 UMA 多处理器</p>
<p>每个处理器对所有存储单元的访问时间是大致相同的</p>
<p>即访问时间与<u>哪个处理器提出</u>及<u>访问哪个字</u>无关</p>
</li>
<li><p>非统一存储访问 NUMA 多处理器</p>
<p>某些访存请求要比其他的快，具体取决于哪个处理器提出了访存请求以及访问哪个字</p>
<p>这是由于主存被分割并分配给了同一机器上的不同处理器或内存控制器</p>
<p>处理器中不带高速缓存时，被称为 NC-NUMA；处理器中带有一致性高速缓存时，被称为 CC-NUMA</p>
</li>
</ul>
<p>早期计算机，内存控制器没有整合进 CPU，访存操作需要经过北桥芯片（集成了内存控制器并与内存相连），CPU 通过前端总线和北桥芯片相连，这就是统一存储访问(UMA)构架</p>
<p>随着 CPU 性能提升由提高主频转到增加 CPU 数量（多核、多 CPU），越来越多的 CPU 对前端总线的争用使得前端总线成为了瓶颈。为消除 UMA 架构的瓶颈，非统一存储访问(NUMA)构架诞生，内存控制器被集成到 CPU 内部</p>
<p>NUMA 架构中，每个 CPU 都独立连接到一部分内存，CPU 直连的这部分内存被称为本地内存。CPU 之间通过 QPI 总线相连，内存的访问出现了本地和远程的区别。显然访问本地内存要快于访问远程内存</p>
<p>显然 NUMA 构架比 UMA 构架的运算扩展性要强：UMA 构架由于所有 CPU 共享相同的内存，增加 CPU 路数会加大访存冲突（通常 2 或 4 路性能最好），而 NUMA 理论上支持无限扩展</p>
<p>UMA 构架需要解决 Cache 一致性问题：还是由于所有 CPU 共享同一内存空间，每个 CPU 的 Cache 都是共享内存中的一部分副本。这里的 Cache 一致性既包括 Cache 和内存之间的一致性，还包括各 CPU 的 Cache 之间的一致性</p>
<p>多处理器在操作共享变量时需要进行同步，常用方法是通过对共享变量加锁来控制对共享变量的互斥访问</p>
<h2 id="刷题笔记"><a href="#刷题笔记" class="headerlink" title="刷题笔记"></a>刷题笔记</h2><ul>
<li>计算机字长 n 位，n 位 CPU，都是指数据字长</li>
<li>主存地址位数取决于存储器字数</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zero</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zerooo.top/2024/01/06/CO5_%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/">https://zerooo.top/2024/01/06/CO5_%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zerooo.top" target="_blank">ZERO</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/06/CO6_%E6%80%BB%E7%BA%BF/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">总线 | CO</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/06/CO4_%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">指令系统 | CO</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/01/06/CO7_%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/" title="输入输出系统 | CO"><img class="cover" src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-06</div><div class="title">输入输出系统 | CO</div></div></a></div><div><a href="/2024/01/06/CO1_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" title="计算机系统概述 | CO"><img class="cover" src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-06</div><div class="title">计算机系统概述 | CO</div></div></a></div><div><a href="/2024/01/06/CO2_%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/" title="数据的表示与运算 | CO"><img class="cover" src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-06</div><div class="title">数据的表示与运算 | CO</div></div></a></div><div><a href="/2024/01/06/CO6_%E6%80%BB%E7%BA%BF/" title="总线 | CO"><img class="cover" src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-06</div><div class="title">总线 | CO</div></div></a></div><div><a href="/2024/01/06/CO3_%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/" title="存储系统 | CO"><img class="cover" src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-06</div><div class="title">存储系统 | CO</div></div></a></div><div><a href="/2024/01/06/CO4_%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" title="指令系统 | CO"><img class="cover" src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-06</div><div class="title">指令系统 | CO</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zero</div><div class="author-info__description">一些记录</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zero-P" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:zerooop@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU-%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">CPU 的功能和基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.</span> <span class="toc-text">CPU 的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.1.</span> <span class="toc-text">控制器的功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.2.</span> <span class="toc-text">运算器的功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">CPU 的基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.1.</span> <span class="toc-text">运算器的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">控制器的结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">指令执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="toc-number">2.1.</span> <span class="toc-text">指令周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">2.2.</span> <span class="toc-text">指令周期的数据流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">取指周期数据流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B4%E5%9D%80%E5%91%A8%E6%9C%9F%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">2.2.2.</span> <span class="toc-text">间址周期数据流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">2.2.3.</span> <span class="toc-text">执行周期数据流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">2.2.4.</span> <span class="toc-text">中断周期数据流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%96%B9%E6%A1%88"><span class="toc-number">2.3.</span> <span class="toc-text">指令执行方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="toc-number">2.3.1.</span> <span class="toc-text">单指令周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="toc-number">2.3.2.</span> <span class="toc-text">多指令周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%96%B9%E6%A1%88"><span class="toc-number">2.3.3.</span> <span class="toc-text">流水线方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">数据通路的功能和基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.</span> <span class="toc-text">数据通路的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">数据通路的基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E6%A6%82%E5%BF%B5"><span class="toc-number">3.2.1.</span> <span class="toc-text">补充概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-%E5%86%85%E9%83%A8%E5%8D%95%E6%80%BB%E7%BA%BF%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.2.</span> <span class="toc-text">CPU 内部单总线方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-%E5%86%85%E9%83%A8%E4%B8%89%E6%80%BB%E7%BA%BF%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.3.</span> <span class="toc-text">CPU 内部三总线方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%93%E7%94%A8%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.4.</span> <span class="toc-text">专用数据通路方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%91%A8%E6%9C%9F%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">单周期处理器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">控制器的功能和工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD"><span class="toc-number">4.1.</span> <span class="toc-text">控制器的结构和功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">硬布线控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E5%9B%BE"><span class="toc-number">4.2.1.</span> <span class="toc-text">硬布线控制单元图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">4.2.2.</span> <span class="toc-text">时序控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.3.</span> <span class="toc-text">CPU 控制方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.2.4.</span> <span class="toc-text">设计步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.2.5.</span> <span class="toc-text">设计实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">微程序控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.3.1.</span> <span class="toc-text">微程序控制的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F-%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">4.3.2.</span> <span class="toc-text">微指令的编码方式&#x2F;控制方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E5%9C%B0%E5%9D%80%E5%BD%A2%E6%88%90%E6%96%B9%E5%BC%8F"><span class="toc-number">4.3.3.</span> <span class="toc-text">微指令的地址形成方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.3.4.</span> <span class="toc-text">微指令的格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E7%BB%84%E6%88%90%E5%92%8C%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">4.3.5.</span> <span class="toc-text">微程序控制器组成和工作过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.3.6.</span> <span class="toc-text">微程序控制单元的设计步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%AF%AB%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.3.7.</span> <span class="toc-text">动态微程序设计和毫微程序设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E5%B8%83%E7%BA%BF-vs-%E5%BE%AE%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.4.</span> <span class="toc-text">硬布线 vs 微程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">异常和中断机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">6.</span> <span class="toc-text">指令流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">指令流水线的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.2.</span> <span class="toc-text">流水线的基本实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%80%E9%9C%80%E9%83%A8%E4%BB%B6"><span class="toc-number">6.2.1.</span> <span class="toc-text">所需部件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7"><span class="toc-number">6.2.2.</span> <span class="toc-text">控制信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">6.2.3.</span> <span class="toc-text">执行过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%86%92%E9%99%A9%E4%B8%8E%E5%A4%84%E7%90%86"><span class="toc-number">6.3.</span> <span class="toc-text">流水线的冒险与处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%86%92%E9%99%A9"><span class="toc-number">6.3.1.</span> <span class="toc-text">结构冒险</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9"><span class="toc-number">6.3.2.</span> <span class="toc-text">数据冒险</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%86%92%E9%99%A9"><span class="toc-number">6.3.3.</span> <span class="toc-text">控制冒险</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">6.4.</span> <span class="toc-text">流水线的性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E7%8E%87-TP"><span class="toc-number">6.4.1.</span> <span class="toc-text">吞吐率 TP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%80%9F%E6%AF%94-S"><span class="toc-number">6.4.2.</span> <span class="toc-text">加速比 S</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%88%E7%8E%87-E"><span class="toc-number">6.4.3.</span> <span class="toc-text">效率 E</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF"><span class="toc-number">6.5.</span> <span class="toc-text">高级流水线技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%A0%87%E9%87%8F%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF"><span class="toc-number">6.5.1.</span> <span class="toc-text">超标量流水线技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF"><span class="toc-number">6.5.2.</span> <span class="toc-text">超流水线技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E9%95%BF%E6%8C%87%E4%BB%A4%E5%AD%97"><span class="toc-number">6.5.3.</span> <span class="toc-text">超长指令字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">7.</span> <span class="toc-text">多处理器的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SISD%E3%80%81SIMD%E3%80%81MIMD"><span class="toc-number">7.1.</span> <span class="toc-text">SISD、SIMD、MIMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.2.</span> <span class="toc-text">硬件多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">7.3.</span> <span class="toc-text">多核处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">7.4.</span> <span class="toc-text">共享内存多处理器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0"><span class="toc-number">8.</span> <span class="toc-text">刷题笔记</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/12/DS5_%E6%A0%91/" title="树 | DS"><img src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="树 | DS"/></a><div class="content"><a class="title" href="/2024/01/12/DS5_%E6%A0%91/" title="树 | DS">树 | DS</a><time datetime="2024-01-12T01:14:08.000Z" title="发表于 2024-01-12 09:14:08">2024-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/11/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" title="常用算法模板"><img src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用算法模板"/></a><div class="content"><a class="title" href="/2024/01/11/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" title="常用算法模板">常用算法模板</a><time datetime="2024-01-11T09:50:08.000Z" title="发表于 2024-01-11 17:50:08">2024-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/11/DS3_%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/" title="栈、队列和数组 | DS"><img src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="栈、队列和数组 | DS"/></a><div class="content"><a class="title" href="/2024/01/11/DS3_%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/" title="栈、队列和数组 | DS">栈、队列和数组 | DS</a><time datetime="2024-01-11T01:16:04.000Z" title="发表于 2024-01-11 09:16:04">2024-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/10/DS2_%E7%BA%BF%E6%80%A7%E8%A1%A8/" title="线性表 | DS"><img src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线性表 | DS"/></a><div class="content"><a class="title" href="/2024/01/10/DS2_%E7%BA%BF%E6%80%A7%E8%A1%A8/" title="线性表 | DS">线性表 | DS</a><time datetime="2024-01-10T01:34:05.000Z" title="发表于 2024-01-10 09:34:05">2024-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/09/%E5%8C%97%E5%A4%A7%E8%82%96%E8%87%BB%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B%E7%AC%94%E8%AE%B0-BTC/" title="北大肖臻《区块链技术与应用》笔记 - BTC"><img src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="北大肖臻《区块链技术与应用》笔记 - BTC"/></a><div class="content"><a class="title" href="/2024/01/09/%E5%8C%97%E5%A4%A7%E8%82%96%E8%87%BB%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B%E7%AC%94%E8%AE%B0-BTC/" title="北大肖臻《区块链技术与应用》笔记 - BTC">北大肖臻《区块链技术与应用》笔记 - BTC</a><time datetime="2024-01-09T14:23:52.000Z" title="发表于 2024-01-09 22:23:52">2024-01-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zero</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script src="/js/catalog.js?1"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>