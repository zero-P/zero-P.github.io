<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>内存管理 | OS | ZERO</title><meta name="keywords" content="操作系统"><meta name="author" content="zero"><meta name="copyright" content="zero"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="内存管理概念引入多道程序的并发执行后，进程之间共享的不仅仅是处理机，还有主存储器。然而，共享主存会形成一些特殊的挑战。若不对内存进行管理，则易导致内存数据的混乱，以至于限制进程的并发执行。因此，为了更好地支持多道程序并发执行，必须进行内存管理 基本原理和要求 内存管理 操作系统对内存的划分和动态分配  内存管理目的   方便用户 提高内存利用率   内存管理主要功能 内存空间的分配与回收 地址转换">
<meta property="og:type" content="article">
<meta property="og:title" content="内存管理 | OS">
<meta property="og:url" content="https://zerooo.top/2024/03/10/OS3_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="ZERO">
<meta property="og:description" content="内存管理概念引入多道程序的并发执行后，进程之间共享的不仅仅是处理机，还有主存储器。然而，共享主存会形成一些特殊的挑战。若不对内存进行管理，则易导致内存数据的混乱，以至于限制进程的并发执行。因此，为了更好地支持多道程序并发执行，必须进行内存管理 基本原理和要求 内存管理 操作系统对内存的划分和动态分配  内存管理目的   方便用户 提高内存利用率   内存管理主要功能 内存空间的分配与回收 地址转换">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg">
<meta property="article:published_time" content="2024-03-10T06:39:58.000Z">
<meta property="article:modified_time" content="2024-03-20T02:37:36.289Z">
<meta property="article:author" content="zero">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg"><link rel="shortcut icon" href="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/favicon.png"><link rel="canonical" href="https://zerooo.top/2024/03/10/OS3_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '内存管理 | OS',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-20 10:37:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/catalog.css?1"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZERO</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">内存管理 | OS</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-10T06:39:58.000Z" title="发表于 2024-03-10 14:39:58">2024-03-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-20T02:37:36.289Z" title="更新于 2024-03-20 10:37:36">2024-03-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%80%83%E7%A0%94408/">考研408</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="内存管理 | OS"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h2><p>引入多道程序的并发执行后，进程之间共享的不仅仅是处理机，还有主存储器。然而，共享主存会形成一些特殊的挑战。若不对内存进行管理，则易导致内存数据的混乱，以至于限制进程的并发执行。因此，<strong>为了更好地支持多道程序并发执行</strong>，必须进行内存管理</p>
<h3 id="基本原理和要求"><a href="#基本原理和要求" class="headerlink" title="基本原理和要求"></a>基本原理和要求</h3><ul>
<li><p>内存管理</p>
<p>操作系统对内存的划分和动态分配</p>
</li>
<li><p>内存管理目的 </p>
<ol>
<li>方便用户</li>
<li>提高内存利用率</li>
</ol>
</li>
<li><p>内存管理主要功能</p>
<p>内存空间的分配与回收</p>
<p>地址转换（逻辑 → 物理）</p>
<p>内存空间的扩充（逻辑上） </p>
<p>内存共享（受控访问）</p>
<p>存储保护</p>
</li>
<li><p>将用户程序变为可在内存中执行的程序的步骤</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os31.png" width="480px"/></dev>

<ol>
<li><p>编译</p>
<p>由编译程序(compiler)对用户源程序进行编译，形成若干个目标模块(object module)</p>
</li>
<li><p>链接</p>
<p>由链接程序(linker)将编译后形成的一组目标模块以及它们所需要的库函数链接在一起，形成一个完整的装入模块(load module)</p>
</li>
<li><p>装入</p>
<p>由装入程序(loader)将装入模块装入内存</p>
</li>
</ol>
</li>
<li><p>目标文件</p>
<p>目标文件有三种形式：</p>
<ol>
<li><p>可重定位目标文件</p>
<p>包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件</p>
</li>
<li><p>可执行目标文件</p>
<p>包含二进制代码和数据，其形式可以被直接复制到内存并执行</p>
</li>
<li><p>共享目标文件</p>
<p>一种特殊类型的可重定位目标文件，可以在装入或者运行时被动态地装入内存并链接</p>
</li>
</ol>
<p>编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件</p>
<p>从技术上来说，一个目标模块就是一个字节序列，而一个目标文件就是一个以文件形式存放在磁盘中的目标模块，两个术语常常互换使用</p>
</li>
<li><p>逻辑地址空间和物理地址空间</p>
<p><strong>编译后</strong>，每个模块都从 0 号开始编址，称为<strong>该目标模块</strong>的相对地址（<strong>逻辑地址</strong>）</p>
<p>当链接程序将各模块<strong>链接</strong>成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成<strong>统一的从 0 号单元开始编址的逻辑地址空间</strong>（注意区分编译后形成的逻辑地址和链接后形成的最终逻辑地址）</p>
<p>物理地址空间是指内存中物理单元的集合，它是地址转换的最终地址</p>
</li>
<li><p>程序的链接方式</p>
<ol>
<li><p>静态链接</p>
<p>在程序运行之前完成链接，之后不再拆开</p>
<p>需要修改目标模块中的相对地址以及变换外部调用符号（将每个模块中所用的外部调用符号也都变换为相对地址）</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os32.png" width="400px"/></dev>
</li>
<li><p>装入时动态链接</p>
<p>直接将目标模块一个个装入内存，边装入边链接</p>
<p>即在装入一个目标模块时，若发生一个外部模块调用事件，将引起装入程序去找出相应的外部目标模块，链接完成后将其装入内存</p>
<p>优点：便于修改和更新（各目标模块分开存放）；便于实现对目标模块的共享</p>
</li>
<li><p>运行时动态链接</p>
<p>将对某些模块的链接推迟到程序执行中需要该目标模块时才进行</p>
<p>有些模块不一定/基本用不到，所以一开始就不全装进内存</p>
<p>优点：加快装入过程；节省大量内存空间</p>
</li>
</ol>
</li>
<li><p>重定位</p>
<p>在装入时对目标程序中的相对地址的修改过程（逻辑地址 → 物理地址）</p>
</li>
<li><p>程序的装入方式</p>
<ol>
<li><p>绝对装入</p>
<p>直接按绝对地址装入内存，逻辑地址与物理地址相同</p>
<p>用户程序经编译后，将产生物理地址。绝对地址既可在编译或汇编时给出，也可由程序员直接赋予，但通常是在程序中采用符号地址，在编译或汇编时再将这些符号地址转为绝对地址</p>
<p>使用这种方式的前提是，计算机系统很小，且<strong>仅能运行单道程序</strong>，此时完全有可能知道程序将驻留在内存的什么位置</p>
</li>
<li><p>可重定位装入/静态重定位</p>
<p>根据内存的当前状况，将装入模块装入内存的适当位置，装入时进行重定位</p>
<p>特点：一次分配作业要求的全部内存空间（给不了就不装）；作业进入内存后，整个运行期间不能在内存中移动，也不能再申请内存空间</p>
</li>
<li><p>动态运行时装入/动态重定位</p>
<p>地址转换推迟到程序真正执行时进行（故装入模块装入内存后所有地址仍都是逻辑地址） </p>
<p>可重定位方式不允许程序运行时在内存中移动位置，但在实际运行过程中程序在内存中的位置可能经常要改变，例如在具有对换功能的系统中，一个进程可能被多次换出换入，每次换入后的位置通常是不同的，在这种情况下就应采用动态运行时装入的方式</p>
<p>需要一个重定位寄存器的支持：目标模块装入内存时无需任何修改；一个程序由若干相对独立的目标模块组成时，每个目标模块各装入一个存储区域，而这些存储区域可以不相邻</p>
<p>特点：可将程序分配到不连续的存储区；装入程序的部分代码即可投入运行，运行期间再根据需要动态申请分配内存；便于程序段的共享，可向用户提供一个比存储空间大得多的地址空间</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os33.png" width="600px"/></dev>


</li>
</ol>
</li>
</ul>
<blockquote>
<p>重定位寄存器在整个系统中只设置一个，用来存放正在执行的程序或正在访问的数据在内存中的始址。因为 CPU 在同一时刻只能执行一条指令或访问一条数据，所以为每道程序（数据）设置一个寄存器没有必要（同时也不现实，寄存器很贵，而程序的道数很多且无法预估），只需在切换程序执行时重置寄存器内容</p>
<p>页表寄存器 PTR 同理</p>
</blockquote>
<ul>
<li><p>进程的内存映像（虚拟地址空间）</p>
<p>每个高级语言源程序经编译、汇编、链接等处理生成可执行的二进制机器目标代码时，都被映射到一个统一的虚拟地址空间。所谓“统一”是指不同的可执行文件所映射的虚拟地址空间大小一样，地址空间的区域划分结构也相同，这简化了链接器的设计和实现，也简化了程序的加载过程</p>
<p>下图是 IA-32 + Linux 系统中一个进程对应的虚拟地址空间映像</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20220918232125238.png" width="900px"/></dev>

<p>一个进程的内存映像一般有这些要素：代码段、数据段、进程控制块、堆、栈</p>
<p>每个区域都有相应的起始位置</p>
</li>
<li><p>内存保护的两种方法</p>
<p>内存保护是内存管理的一部分，是操作系统的任务，但出于安全性和效率考虑，必须由硬件实现，所以需要操作系统和硬件机构的合作来完成</p>
<ol>
<li><p>在 CPU 中设置一对上、下限寄存器，存放用户作业在内存中的上下限地址（应该是物理地址）</p>
</li>
<li><p>重定位寄存器/基址寄存器 + 界地址寄存器/限长寄存器</p>
<p>内存管理机构动态地将逻辑地址与界地址寄存器进行比较，若未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元访问（即读/写）重定位寄存器和界地址寄存器时必须使用特权指令</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os34.png" width="550px"/></dev>

</li>
</ol>
<blockquote>
<p>页式管理中有页地址越界保护，段式管理中有段地址越界保护（2 次）</p>
</blockquote>
</li>
<li><p>内存共享</p>
<p>进程内存空间中只有只读的区域才可以共享</p>
</li>
<li><p>可重入代码/纯代码</p>
<p>一种允许多个进程同时访问但不允许被任何进程修改的代码</p>
<p>可重入程序主要是通过共享来使用同一块存储空间的，或通过动态链接的方式将所需的程序段映射到相关进程中去</p>
<p>其最大的优点是减少了对程序段的调入/调出，从而减少了对换数量</p>
</li>
</ul>
<h3 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h3><p>多道程序环境下用来扩充内存的两种方法（以时间换空间）</p>
<h4 id="覆盖（同一个进程）"><a href="#覆盖（同一个进程）" class="headerlink" title="覆盖（同一个进程）"></a>覆盖（同一个进程）</h4><p>把用户空间分成一个固定区和若干覆盖区，程序经常活跃的部分放在固定区，其余部分按调用关系分段，将那些即将要访问的段放入覆盖区，其他段放在外存中</p>
<p>打破了必须将一个进程的全部信息装入主存后才能运行的限制（但当同时运行程序的代码量大于主存时仍不能运行）</p>
<p>覆盖技术要求给出程序段之间的覆盖结构，对用户和程序员不透明，所以对于主存无法存放用户程序的矛盾，现代操作系统是通过虚拟内存技术来解决的，覆盖技术已成历史</p>
<p>覆盖技术是早期在单一连续存储管理中使用的扩大存储容量的一种技术，它同样可用于固定分区分配的存储管理</p>
<h4 id="交换（不同进程-作业之间）"><a href="#交换（不同进程-作业之间）" class="headerlink" title="交换（不同进程/作业之间）"></a>交换（不同进程/作业之间）</h4><p>换出：把处于等待状态（阻塞/就绪）的程序从内存移到外存</p>
<p>换入：把准备好竞争 CPU 运行的程序从外存移到内存</p>
<p>中级调度采用的就是交换技术</p>
<p>若换出进程，须确保该进程完全处于空闲状态</p>
<p>为了有效使用 CPU，需要使每个进程的执行时间比交换时间长</p>
<p>交换需要备份存储，通常是快速磁盘，足够大，并提供对这些内存映像的直接访问</p>
<p>交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来可能很快</p>
<p>交换通常在有许多进程运行且内存空间吃紧时开始启动，而在系统负荷降低时就暂停</p>
<p>普通的交换使用不多，但交换策略的某些变体在许多系统（如 UNIX）中仍发挥作用</p>
<p>交换技术在现代操作系统中仍具有较强的生命力</p>
<p>正在 I/O 操作的进程不能被换出；处于临界区的进程不一定</p>
<p>对外存对换区的管理应以提高换入、换出速度为主要目标</p>
<h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><p>为一个用户分配一个连续的内存空间</p>
<h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><p>内存在此方式下分为系统区和用户区。系统区仅供操作系统使用，通常在低地址部分；用户区内存中仅有一道用户程序，即整个内存的用户空间由该程序独占</p>
<p>优点：简单、无外部碎片，无须进行内存保护（内存中永远只有一道程序），可采用覆盖技术，不需要额外的技术支持</p>
<p>缺点：只能用于单用户、单任务的操作系统中，有内部碎片，存储器利用率极低</p>
<h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><p>将用户空间划分为若干固定大小的区域，每个分区只装入一道作业</p>
<p>分区划分方法：</p>
<ol>
<li><p>分区大小相等</p>
<p>用于利用一台计算机去控制多个相同对象的场合</p>
<p>缺乏灵活性</p>
</li>
<li><p>分区大小不等</p>
<p>划分为多个较小的分区、适量的中等分区和少量大分区</p>
<p>为便于内存分配，通常将分区按大小排队，并为之建立一张分区说明表（起始地址、大小、状态）</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os35.png" width="230px"/></dev>

<p>未找到合适分区时，则拒绝为该用户程序分配内存</p>
</li>
</ol>
<p>优点：可用于多道程序设计的最简单的存储分配，无外部碎片</p>
<p>缺点：</p>
<ol>
<li>程序可能太大而放不进任何一个分区（此时用户得用覆盖技术）</li>
<li>存在内部碎片</li>
<li>不能实现多进程共享一个主存区，存储空间利用率低</li>
</ol>
<p>固定分区分配很少用于现在通用的操作系统中，但在某些用于控制多个相同对象的控制系统中仍发挥着一定的作用</p>
<h4 id="动态分区分配-可变分区分配"><a href="#动态分区分配-可变分区分配" class="headerlink" title="动态分区分配/可变分区分配"></a>动态分区分配/可变分区分配</h4><p>不预先划分内存，而是在进程装入内存时，动态地为之建立大小正好合适的分区</p>
<p>内存空闲分区的分配算法（动态分区的分配策略）：</p>
<ol>
<li><p>首次适应算法(First Fit)（简单顺序查找）</p>
<p>从低地址开始查找第一个能满足大小的空闲分区</p>
<p>最简单，通常也是最好和最快的</p>
<p>会使得内存的低地址部分出现很多小的空闲分区，而每次分配查找时都要经过这些分区，因此增加了查找的开销</p>
</li>
<li><p>临近适应算法(Next Fit)/循环首次适应算法（简单顺序查找）</p>
<p>由首次适应算法演变而成，不同之处是，分配内存时从上次查找结束的位置开始继续查找</p>
<p>试图解决首次适应算法的问题。但它常常导致在内存空间的尾部分裂成小碎片（因为在一遍扫描中，内存前面部分使用后再释放时，不会参与分配）</p>
<p>通常比首次适应算法要差</p>
</li>
<li><p>最佳适应算法(Best Fit)（排序/遍历）</p>
<p>空闲分区会按容量增序形成分区链，从链首开始查找第一个能满足大小的空闲分区</p>
<p>性能通常很差，<strong>会容易产生最多的碎片</strong>，因为每次最佳的分配会留下很小的难以利用的内存块</p>
</li>
<li><p>最坏适应算法(Worst Fit)/最大适应算法(Largest Fit)（排序/遍历）</p>
<p>空闲分区会按容量降序形成分区链，从链首开始查找第一个能满足大小的空闲分区（即挑选出最大的空闲分区）</p>
</li>
</ol>
<p>与固定分区类似，可设置一张空闲分区链（表），包含空闲分区的始址和大小信息，在分配和回收内存时需相应修改。注意，回收内存时可能出现四种情况，考试常考</p>
<p>随着进程的换入换出，会出现更多更小的外部碎片</p>
<p>可使用紧凑(compaction)技术克服外部碎片，即操作系统不时地对进程进行移动和整理。这需要动态重定位寄存器的支持，且相对费时（紧凑的过程类似于 Windows 系统中的磁盘碎片整理程序，只不过后者是对外存空间的紧凑）</p>
<hr>
<p>三种内存连续分配方式的比较：</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os37.png" width="600px"/></dev>

<h3 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h3><h4 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h4><ul>
<li><p>引入目的</p>
<p>固定分区会产生内部碎片，动态分区会产生外部碎片，为了内存的使用能尽量避免碎片的产生，故引入了分页的思想</p>
</li>
<li><p>思想</p>
<p>主存和每个进程以块为单位进行划分。进程在执行时，以块为单位逐个申请主存中的块空间</p>
<p>进程中的块称为页(page)；内存中的块称为页框/页帧(page frame)；外存也以同样的单位划分，直接称为块或盘块(block)</p>
</li>
<li><p>分页 vs 固定分区</p>
<p>相同：不会产生外部碎片</p>
<p>不同：</p>
<ol>
<li>块相当小</li>
<li>进程也按照块划分</li>
<li>一个程序可占据多个块且不需要连续</li>
<li>分页管理不会产生外部碎片（内部碎片也只有进程申请的最后一个内存块才有，也称页内碎片）</li>
</ol>
</li>
<li><p>逻辑地址结构</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os38.png" width="350px"/></dev>

<p>页号和页内偏移量对用户透明</p>
<p>这里每页大小 $2^{12}$ B = 4KB，最多允许 $2^{20}$ = 2M 页</p>
</li>
<li><p>页表</p>
<p>存储进程页到内存页帧的映射</p>
<p>OS 为每个进程都维护了一个页表，另外还维护一个空闲页框列表</p>
<p>进程在执行时不需要将所有页调入内存页框，而只需将保存有映射关系的页调入内存（不应该是调入内存了才会有映射关系？）</p>
<p>一级页表存放在内存</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os39.png" width="420px"/></dev>

<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os310.png" width="500px"/></dev>
</li>
<li><p>页面大小</p>
<p>应是 2 的整数幂。页面太小则页表过长，占用大量内存，增加硬件地址转换的开销，降低页面换入/换出的效率，并且不能充分利用访存的空间局部性来提高命中率；页面过大则使页内碎片增大，降低内存的利用率</p>
<p>确定页面大小有很多因素，如进程的平均大小、页表占用的长度等</p>
<p>页的大小固定且由系统决定</p>
</li>
<li><p>页表项大小</p>
<p>若逻辑地址空间 32 位、一页 4 KB，则一共有 1M 页，那么页表项至少需要 20 位才能表示完，若以字节为编址单位，则页表项至少为 3B （当然也可以取 4B，更好存储）</p>
<blockquote>
<p>我觉得应该用物理地址长度，这里应该是没考虑虚拟内存</p>
</blockquote>
</li>
<li><p>基本地址变换机构（逻辑地址 → 物理地址）</p>
<p>已知页面大小 L 和 逻辑地址 A，求物理地址 E</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os311.png" width="500px"/></dev>

<p>整个地址变换过程均由硬件自动完成</p>
<p>由上图的第 ③ 步可知，页表必须在物理内存中连续存放</p>
<blockquote>
<p>ps：数组的连续存放是逻辑空间上的连续，而且要是跨页的话不一定是相邻的页</p>
</blockquote>
</li>
<li><p>页表寄存器 PTR (Page-Table Register)</p>
<p>进程未执行时，页表始址和长度一开始放在本进程的 PCB 中，当调度程序调度到某进程时，才将这两个数据装入 PTR。因此在单处理机环境下，虽然系统中可运行多个进程，但只需一个 PTR</p>
</li>
<li><p>存取一个数据/一条指令至少访问两次内存（不考虑 TLB 和 Cache）：</p>
<p>第一次访存是访问页表，得到数据/指令物理地址；第二次根据该物理地址访存去存取数据/指令</p>
</li>
<li><p>分页管理方式需要处理好的两个问题</p>
<ol>
<li>每次操作都需要进行逻辑地址到物理地址的转换，因此地址转换过程必须足够快，否则访存速度会降低</li>
<li>每个进程引入页表，用于存储映射机制，页表不能太大，否则内存利用率会降低</li>
</ol>
</li>
<li><p>快表 TLB (Translation Lookaside Buffer)</p>
<p>是一种相联存储器(Associative Memory)，具有并行查找能力的高速缓冲存储器，位于 CPU，属于 SRAM。基于局部性原理，存放有若干页表项，以减少访问内存的次数</p>
<p>相应地，内存中的页表就称为慢表</p>
<p>和主存（逻辑地址）的映射方式通常采用全相联或组相联方式</p>
</li>
<li><p>具有快表的地址变换机构</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os312.png" width="520px"/></dev>

<p>查页表时，可以先查快表再查慢表，也可以快慢表一起查</p>
<p>一般快表的命中率可达 90% 以上</p>
<p>快表才真正存储了页号（即 Tag 字段，全相联是虚页号，组相联是虚页号去除末尾 $\log_2N$ 位组号的高位的）</p>
</li>
<li><p>两级页表——页表的页表</p>
<blockquote>
<p>一页 4 KB、一个页表项按 4B 来算，若要实现进程对全部逻辑地址空间（32 位）的映射，则每个进程需要 4MB（1024 页）并且<strong>连续</strong>的主存空间存放页表。即使不考虑对全部逻辑地址空间进行映射的情况，以 40MB 的进程为例，页表 40KB，若将所有页表项存放在内存中，则需要 10 个内存页框保存，而整个进程实际执行时只需要几十个页面进入内存，这无疑降低了内存利用率；从另一方面，根据局部性原理，大多数情况下映射所需要的页表项都在页表的同一个页面中，因此 10 页的页表项也并不需要同时保存在内存中</p>
</blockquote>
<p>为了压缩页表，我们进一步延伸映射的思想，就可得到二级分页</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os313.png" width="540px"/></dev>

<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os314.png" width="600px"/></dev>

<p>为了查询方便，顶级页表最多一页。从上图看，二级页表显然也是最多一页，所以记住两级乃至多级页表的每一级页表都不超过一页就行了</p>
<p>两级页表下，页表寄存器应是针对顶级页表设置的</p>
<p>上述对页表施行离散分配的方法，只解决了对于大页表无需大片连续存储空间的问题（顶级页表还是需要连续的），并未解决用较少的内存空间去存放大页表的问题。换言之，只用离散分配空间的办法并未减少页表所占用的内存空间（甚至还增加了）</p>
<p>要解决占用内存过大的问题，可利用虚拟存储器思想，即不用把所有的页表都调入内存，只在需要它时才调入。因此为了表征某页的二级页表是否已经调入内存，还应在顶级页表项中增设一个状态位</p>
<blockquote>
<p>所以采用虚拟内存 + 两级页表的情况下，会发生页表不在内存而需要产生中断去磁盘 I/O 的情况（感觉考题不会这么考，有一点点变态）</p>
</blockquote>
</li>
<li><p>多级页表</p>
<p>建立两级级及多级页表的目的在于建立索引，以便不用浪费内存空间去存储无用的页表项，也不用盲目地顺序式查找页表项</p>
<p>但也导致存取一次数据或指令需要多次访问内存甚至磁盘，会大大增加一次访存的时间</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os315.png" width="400px"/></dev>

<p>优点：页表简单，调入方便</p>
<p>缺点：最后一页存在页内碎片；页不是逻辑上独立的实体，所以处理、保护和共享不及段式方便</p>
</li>
</ul>
<h4 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h4><ul>
<li><p>引入目的</p>
<p>分页通过硬件机制实现，对用户完全透明。分段管理方式的提出则考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及<strong>动态链接</strong>等多方面需要</p>
</li>
<li><p>段的划分</p>
<p>在用户编程时，按照用户进程中的自然段划分逻辑空间，例如主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等</p>
<p>每段从 0 开始编址，并分配一段连续的地址空间内存中</p>
<p>段内要求连续，段间不要求</p>
<p>段长不固定</p>
<p>段号和段内偏移量必须由用户显式提供（高级程序设计语言中由编译程序完成）</p>
</li>
<li><p>逻辑地址结构</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os316.png" width="350px"/></dev>
</li>
<li><p>段表</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os317.png" width="300px"/></dev>

<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os318.png" width="500px"/></dev>
</li>
<li><p>地址变换机构</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20231125145818322.png" width="500px"/></dev>

<p>变换过程与分页类似</p>
<p>从逻辑地址取段号和段内偏移量无法通过除法和取模得到，因为段长不固定，故需要显式提供段号和段内偏移</p>
<p>越界保护除了要比较段表长度和段号，还要比较段长和段内偏移量（而分页中的页内偏移是不可能越界的）</p>
<p>注意上图里是段表寄存器</p>
</li>
<li><p>段的共享</p>
<p>可重入代码和不能修改的数据可以共享</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os320.png" width="580px"/></dev>

<p>分页系统也能实现程序和数据的共享，但远不如分段系统来得方便（分页太散了）</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os321.png" width="500px"/></dev>
</li>
<li><p>优点：具有逻辑独立性（段的分界与程序的自然分界相对应），使得它易于编译、管理、修改和维护，也便于多道程序的共享</p>
<p>缺点：段长可变，分配空间不便，容易在段间留下碎片</p>
</li>
</ul>
<blockquote>
<p>分段和动态分区很像，但分段是进程内分配，属于非连续分配；动态分区是进程间分配，属于连续分配</p>
</blockquote>
<h4 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h4><ul>
<li><p>引入目的</p>
<p>页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享。将这两种存储管理方法结合起来，便形成了段页式存储管理方式</p>
<p>即：用分段方法来分配和管理用户地址空间，用分页方法管理物理存储空间</p>
</li>
<li><p>段页的划分</p>
<p>作业的地址空间先被划分成若干逻辑段，每段再分成若干大小固定的页</p>
<p>对内存空间的管理和分页存储管理一样</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os322.png" width="400px"/></dev>
</li>
<li><p>逻辑地址结构</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os323.png" width="340px"/></dev>
</li>
<li><p>系统为每个进程建立一张段表，每个分段又分别有一张页表</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/Snipaste_2023-06-02_08-24-11.png" width="400px"/></dev>

<p>在一个进程中，段表只有一个，而页表可能有多个</p>
</li>
<li><p>地址变换机构</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20231026153232906.png" width="600px"/></dev>

<p>存取一次数据/指令一般需要访问三次内存（段表→页表→数据/指令）</p>
<p>同样可以使用快表来加快查找，其关键字由段号和页号组成，值是对应的页帧号和保护码</p>
</li>
<li><p>优点：兼具页式和段式的优点，可以按段实现共享和保护</p>
<p>缺点：地址变换过程中需要两次查表，系统开销大</p>
</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li><p>只有固定分区分配可采用静态重定位，其他管理方案均可能在运行过程中改变程序位置</p>
</li>
<li><p>程序的动态链接与程序的逻辑结构有关，分段存储管理有利于动态链接</p>
</li>
<li><p>操作系统实现分区存储管理的代价最小</p>
<p>实现分页、分段和段页式存储管理需要特定的数据结构支持，如页表、段表等。为了提高性能，还需要硬件提供快存和地址加法器等，代价高</p>
<p>分区存储管理是满足多道程序设计的最简单的存储管理方案，特别适合嵌入式等微型设备</p>
</li>
<li><p>确定一个地址需要几个参数，作业地址空间就是几维的</p>
<p>分页管理的地址空间是一维的：页号</p>
<p>分段管理的地址空间是二维的：段号、段内偏移</p>
<p>段页式管理的地址空间是二维的：段号、页号</p>
</li>
<li><p>段表寄存器和页表寄存器的作用都有两个，一是在段表或页表中寻址，二是判断是否越界</p>
</li>
<li><p>采用分页或分段管理后，提供给用户的物理地址空间大小不能确定</p>
<p>页表和段表同样存储在内存中，系统提供给用户的物理地址空间为总空间减去页表或段表的长度。由于页表和段表的长度不能确定，所以提供给用户的物理地址空间大小也不能确定</p>
</li>
</ul>
<h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><p>在物理上扩展内存相对有限，尝试以一些其他可行的方式在逻辑上扩充内存</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>传统存储管理方式的特征</p>
<ol>
<li><p>一次性</p>
<p>作业必须一次性全部装入内存后才能开始运行。这会导致两种情况：</p>
<p>1）不能全部被装入内存的大作业永远无法运行</p>
<p>2）当大量作业要求运行时，由于内存不足以容纳所有作业，只能使少数作业先运行，导致多道程序度的下降</p>
</li>
<li><p>驻留性</p>
<p>作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出，直至作业结束运行</p>
</li>
</ol>
</li>
<li><p>局部性原理</p>
<p>从广义上讲，快表、页高速缓存及虚拟内存技术都属于高速缓存技术，这个技术所依赖的原理就是局部性原理。局部性原理既适用于程序结构，又适用于数据结构</p>
<ol>
<li><p>时间局部性</p>
<p>典型原因是程序中存在大量的循环操作</p>
<p>将近来使用的指令和数据保存到高速缓存中，并使用高速缓存的层次结构</p>
</li>
<li><p>空间局部性</p>
<p>因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的</p>
<p>通常使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中</p>
</li>
</ol>
<p>虛拟内存技术实际上建立了“内存-外存”的两级存储器结构，利用局部性原理实现高速缓存</p>
<p>局部性越好，虚拟存储系统越能更好地发挥作用</p>
</li>
<li><p>虚拟存储器的定义</p>
<p>具有部分装入、请求调入和置换功能，能从逻辑上对内存容量加以扩充的存储器系统</p>
</li>
<li><p>虚拟存储器的主要特征</p>
<ol>
<li><p>多次性</p>
<p>一个作业中的程序和数据无需在作业运行时一次性地全部装入内存</p>
</li>
<li><p>对换性</p>
<p>一个作业中的程序和数据无需在作业运行时常驻内存</p>
</li>
<li><p>虚拟性</p>
<p>从逻辑上扩充内存的容量，使用户所看到的内存容量远大于实际</p>
</li>
</ol>
</li>
<li><p>虚存空间大小的决定因素（要满足的条件）</p>
<ol>
<li>虚存<strong>实际</strong>容量 ≤ 内存容量 + 外存容量</li>
<li>虚存<strong>最大</strong>容量 ≤ 计算机的地址位数能容纳的最大容量</li>
</ol>
</li>
<li><p>虚拟内存技术的实现</p>
<p>需要建立在离散分配的内存管理方式的基础上（采用连续分配方式时，会使相当一部分内存空间都处于暂时或“永久”的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量）</p>
<p>虚拟内存的实现有以下三种方式：</p>
<ol>
<li>请求分页存储管理</li>
<li>请求分段存储管理</li>
<li>请求段页式存储管理</li>
</ol>
<p>需要的硬件支持：</p>
<ol>
<li>一定容量的内存和外存</li>
<li>页表机制/段表机制，作为主要的数据结构</li>
<li>中断机构（缺页中断）</li>
<li>地址变换机构</li>
</ol>
</li>
</ul>
<h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3><p>建立在基本分页系统基础上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能</p>
<p>请求分页式目前最常用的一种实现虚拟存储器的方法</p>
<ul>
<li><p>页表机制</p>
<p>相比基本分页，页表项增加了 4 个字段：</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os326.png" width="500px"/></dev>

<ol>
<li><p>有效位/装入位/状态位 P</p>
<p>指示该页是否已调入内存</p>
</li>
<li><p>引用位/使用位/访问字段 A</p>
<p>记录本页在一段时间内被访问的次数/本页最近已有多长时间未被访问</p>
<p>用来配合置换策略进行设置</p>
</li>
<li><p>脏位/修改位 M</p>
<p>标识该页在调入内存后是否被修改过</p>
<p>以确定页面置换时是否写回外存</p>
</li>
<li><p>外存地址</p>
<p>用于指出该页在外存上的地址</p>
<p>通常是物理块号，供调入该页时参考</p>
</li>
</ol>
<blockquote>
<p>王道 CO3 中把物理块号和外存地址两个字段合并，使用时根据有效位来区分</p>
</blockquote>
</li>
<li><p>缺页中断机构</p>
<p>缺页中断属于内中断</p>
<p>若内存中有空闲块，则分配一个块，将要调入的页装入该块，并修改页表中的相应页表项；若此时内存中没有空闲块，则要淘汰某页（若被淘汰页在内存期间被修改过，则要将其写回外存）</p>
<p>在指令执行期间而非一条指令执行完后产生和处理中断信号</p>
<p>一条指令在执行期间可能产生多次缺页中断</p>
</li>
<li><p>地址变换机构</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os327.png" width="600px"/></dev>

<p>虚拟存储器中，地址映射由操作系统完成，但需要一部分硬件基础的支持</p>
<p>TLB 命中则 Page 必然命中</p>
</li>
<li><p>页式虚拟存储器中，页面很大或很小都会使操作速度变慢，但原因不同：</p>
<p>页面很小：虚拟存储器中包含的页面数就会过多，导致：① 页表的体积过大；② 不能充分利用访存的空间局部性来提高命中率</p>
<p>页面很大：虚拟存储器中的页面数会变少，由于主存的容量比虚拟存储器的容量小，主存中的页面数会更少，进而会导致：① 页面调入/调出时间较长；② 页面调度频率较高，换页次数增加；③ 平均页内剩余空间较大</p>
<p>补充下页面大和页面小的好处：</p>
<p>页面小：平均页内剩余空间较少，可节省存储空间</p>
<p>页面大：减少页表空间</p>
</li>
</ul>
<h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><h4 id="驻留集管理"><a href="#驻留集管理" class="headerlink" title="驻留集管理"></a>驻留集管理</h4><ul>
<li><p>驻留集：给特定进程分配的物理页框</p>
</li>
<li><p>考虑因素</p>
<ol>
<li>每个进程的帧越少，内存中进程就越多，并发度越高，增加了操作系统至少找到一个就绪进程的可能性，减少了由于交换而消耗的处理器时间；但过少会使缺页率增大</li>
<li>为进程增加一些内存帧，将显著降低缺页率</li>
</ol>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os328.png" width="430px"/></dev>

<ol start="3">
<li>给特定进程分配的内存空间超过一定大小后，由于局部性原理，该进程的缺页率不会明显降低</li>
</ol>
</li>
<li><p>驻留集分配策略</p>
<ol>
<li><p>固定分配(fixed-allocation)</p>
<p>为一个进程在内存中分配固定数量的页框，在进程运行期间都不改变</p>
<p>将空闲物理块分配给各个进程，可采用下述几种算法：</p>
<p>1）平均分配算法</p>
<p>2）按比例分配算法（根据进程的大小）</p>
<p>3）优先权分配算法（为重要和紧迫的进程分配较多的物理块）</p>
<p>通常采取的方法是把所有可分配的物理块分成两部分：一部分按比例分配给各个进程；一部分则根据优先权分配</p>
</li>
<li><p>可变分配(variable-allocation)</p>
<p>允许分配给一个进程的页框在该进程的生命周期中不断地发生变化，根据缺页率使进程分得的页框数动态增加或减少</p>
<p>看起来性能更优，但难点在于它要求 OS 评估活动进程的行为，这必然会增加 OS 的软件开销，并取决于处理器平台所提供的硬件机制</p>
</li>
</ol>
</li>
<li><p>置换范围</p>
<ol>
<li><p>局部置换</p>
<p>仅在产生这次缺页的进程的驻留集中选择，以保证分配给该进程的内存空间不变</p>
</li>
<li><p>全局置换</p>
<p>把内存中所有未锁定的页都作为置换的候选页</p>
<p>通常操作系统本身会保持一个空闲物理块队列，仅当空闲物理块用完时，OS 才从内存中选择一页调出（可以是任一进程中的页）</p>
<p>比局部置换更加灵活，但也存在弊端，如它会盲目地给进程增加物理块，从而导致系统多道程序的并发能力下降</p>
</li>
</ol>
</li>
<li><p>策略组合</p>
<ol>
<li>固定分配全局置换：冲突，无此方案</li>
<li>固定分配局部置换：不灵活，难点在确定驻留集大小</li>
<li>可变分配全局置换：可能最容易实现，被许多 OS 使用。难点在于置换页的选择，没有任何原则用于确定应该让哪个进程的驻留集给出一页</li>
<li>可变分配局部置换：不时重新评价进程的分配，增加或减少分配给进程的页框以改善系统性能。需要更复杂的实现，也需要更大的开销，但对比频繁地换入换出所浪费的计算机资源，这种牺牲还是值得的</li>
</ol>
</li>
</ul>
<h4 id="调入页面的时机"><a href="#调入页面的时机" class="headerlink" title="调入页面的时机"></a>调入页面的时机</h4><ul>
<li><p>预调页策略</p>
<p>基于局部性原理，以预测为基础，将那些预计在不久之后便会被访问的页面预先调入内存</p>
<p>目前成功率仅为 50%，因此主要用于进程的首次调入（由程序员指出应先调入哪些页）</p>
</li>
<li><p>请求调页策略</p>
<p>请求了再调</p>
<p>优点：易于实现</p>
<p>缺点：每次只调一页，调入/调出页面数多时会花费过多的 I/O 开销</p>
<blockquote>
<p>一般情况下两种调页策略同时使用：运行前预调入，运行期间请求调入</p>
</blockquote>
</li>
</ul>
<h4 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a>从何处调入页面</h4><ul>
<li>请求分页系统的外存分为两部分：<ol>
<li>文件区：存放文件（通常采用离散分配）</li>
<li>对换区：存放对换页面（通常采用连续分配，因此磁盘 I/O 比文件区快）</li>
</ol>
</li>
<li>三种情况：<ol>
<li>对换区足够：全从对换区调入。进程运行前需要将与该进程有关的文件从文件区复制到对换区</li>
<li>对换区不够：不会被修改的文件都从文件区调入。需要调出这些文件时，因为它们未被修改而不必被调出。对于可能被修改的部分，换出时调到对换区，以后需要时就从对换区调入（因为读比写快）</li>
<li>UNIX 方式：与进程有关的文件一开始都放在文件区，换出时再都放在对换区（因此，文件区存放的都是未运行过的页面，对换区存放的都是曾经运行过但又被换出的页面）。UNIX 允许页面共享，若某进程请求的页面已被其他进程调入内存时便无需再调入</li>
</ol>
</li>
</ul>
<h4 id="如何调入页面"><a href="#如何调入页面" class="headerlink" title="如何调入页面"></a>如何调入页面</h4><p>当进程所访问的页面不在内存中时（存在位为 0），便向 CPU 发出缺页中断，中断响应后便转入缺页中断处理程序。该程序通过查找页表得到该页的物理块（外存），此时如果内存末满，则启动磁盘 I/O，将所缺页调入内存，并修改页表。如果内存已满，则先按某种置换算法和置换范围从内存中选出一页准备换出；如果该页未被修改过（修改位为 0），则无须将该页写回磁盘；但若该页已被修改（修改位为 1），则必须将该页写回磁盘对换区，然后将所缺页调入内存，并修改页表中的相应表项，置其存在位为 1。调入完成后，进程就可利用修改后的页表形成所要访问数据的内存地址</p>
<p>先缺页中断，后续处理由缺页中断处理程序负责</p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>进程运行时，若其访问的页面不在内存中而需将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区（感觉有点问题，因为脏页才需要写回）</p>
<p>好的页面置换算法应有较低的页面更换频率</p>
<h4 id="最佳置换算法-OPT"><a href="#最佳置换算法-OPT" class="headerlink" title="最佳置换算法 OPT"></a>最佳置换算法 OPT</h4><p>换出以后永不使用或最长时间内不再被访问的页面</p>
<p>理想算法（因为无法预知未来），无法实现</p>
<p>能得到最低的缺页率，故用来评价其他算法</p>
<h4 id="先进先出页面置换算法-FIFO"><a href="#先进先出页面置换算法-FIFO" class="headerlink" title="先进先出页面置换算法 FIFO"></a>先进先出页面置换算法 FIFO</h4><p>优先淘汰最早进入内存的页面，即在内存中驻留时间最久的页面</p>
<p>实现简单（队列）</p>
<p>算法性能差：算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问</p>
<p>可能出现 Belady 异常：给进程分配的物理块增多，缺页率反而上升（只有 FIFO 算法可能出现）</p>
<h4 id="最近最久未使用算法-LRU"><a href="#最近最久未使用算法-LRU" class="headerlink" title="最近最久未使用算法 LRU"></a>最近最久未使用算法 LRU</h4><p>选择最近最长时间未访问的页面予以淘汰（认为它们在最近的将来也不太可能会被访问）</p>
<p>为每个页面设置访问字段，来记录该页距离上次被访问的时间</p>
<p>算法性能较好，性能接近于 OPT 算法：利用“最近的过去”作为“最近的将来”的近似，以“过去”预测“未来”</p>
<p>属于堆栈类算法（其实也是变相的 FIFO，只不过用栈实现，淘汰栈底）</p>
<p>实现起来开销大，并需要寄存器和栈的硬件支持。开销大的原因是需要对所有的页排序，而需要硬件支持只是耗费高的体现而非原因</p>
<h4 id="时钟置换算法-CLOCK"><a href="#时钟置换算法-CLOCK" class="headerlink" title="时钟置换算法 CLOCK"></a>时钟置换算法 CLOCK</h4><p>某进程的所有页面（或整个内存的页帧）排成一循环缓冲链</p>
<p>选择将最近未使用的页面置换出去，因此又称最近未用算法 NRU</p>
<ul>
<li><p>简单 CLOCK 算法</p>
<p>给内存中的每帧关联一个附加位，称为使用位 U（应该是页表项的<a target="_blank" rel="noopener" href="https://www.codenong.com/cs105272624/">访问位</a>）</p>
<p>根据置换策略（全局/局部），将候选页通过指针链接成一个循环队列，并用一个替换指针与之关联</p>
<p>当某页被装入或访问时，U 置 1</p>
<p>置换时顺序查找循环链：U 为 0，置换该页；U 为 1，改置为 0；替换指针前移</p>
</li>
<li><p>改进型 CLOCK 算法</p>
<p>除考虑页面使用情况外，还增加了置换代价</p>
<p>增加修改位 M，某页被修改时置 1</p>
<p>增加使用的位数可使时钟算法更有效（位数减少至 0 则退化为 FIFO）</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os329.png" width="360px"/></dev>

<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os330.png" width="320px"/></dev>

<p>注意：第一轮扫描不改变访问位，第二轮扫描期间再将所有扫描过的页面访问位置 0。若第二轮也失败，此时所有帧的访问位都已复 0，则在接下来的扫描中一定能找到被淘汰的页</p>
<blockquote>
<p>U 指示未来被访问的可能性；M 代表置换代价，被修改过的页在置换前还须写回，造成时间开销。之所以 U=0，M=1 的页要比 U=1，M=0 的页优先被淘汰，是因为 U 为首要考虑因素（操作系统中的页面置换算法都有一个原则，即尽可能保留访问过的页面）。虽然置换这样的页必须先写回，但根据局部性原理，它不会很快被用到</p>
</blockquote>
</li>
</ul>
<h3 id="抖动与工作集"><a href="#抖动与工作集" class="headerlink" title="抖动与工作集"></a>抖动与工作集</h3><ul>
<li><p>系统并发度与处理机利用率</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os331.png" width="480px"/></dev>
</li>
<li><p>抖动(thrashing)/颠簸</p>
<p>频繁的页面调度行为（换页时间 ＞ 执行时间）</p>
<p>在页面置换过程中，一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上又要换出主存</p>
<p>可以简单理解为缺页率高</p>
<p>根本原因：系统中同时运行的进程太多，使得分配给每个进程的物理块太少，不能满足进程正常运行的基本要求</p>
<p>主要原因：页面置换算法不合理</p>
</li>
<li><p>抖动的解决</p>
<ol>
<li>挂起一些进程，释放它们的帧（减少多道程序的度数）</li>
<li>增大内存的容量</li>
</ol>
<blockquote>
<p>增大交换区和使用更快的交换区都没用</p>
</blockquote>
</li>
<li><p>工作集</p>
<p>工作集 W：在某段时间间隔 Δ 里，进程实际所要访问页面的集合</p>
<p>一般来说，工作集 W 可由时间 t 和工作集窗口大小 Δ 来确定，即工作集 W 为 t 时刻进程的工作集为在时间间隔 (t-Δ, t) 中引用页面的集合</p>
<p>实际应用中，工作集窗口会设置的很大，即对于局部性好的程序，工作集大小一般会比工作集窗口小很多</p>
<p>工作集反映了进程在<strong>接下来一段时间</strong>内很有可能会频繁访问的页面集合</p>
<p>为了防止抖动，一般来说分配给进程的物理块数（即驻留集大小）要大于工作集大小</p>
</li>
<li><p>稳定阶段（局部性阶段）与瞬变阶段交替出现</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/408/os/os332.png" width="530px"/></dev>

<p>在瞬变阶段，来自原局部性阶段中的某些页仍留在窗口 Δ 中，导致访问新页时工作集大小剧增。当窗口滑过这些页访问后，工作集大小减小，直到它包含那些满足新的局部性的页</p>
</li>
<li><p>工作集模型（工作集策略）</p>
<ol>
<li><p>原理</p>
<p>让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块</p>
<p>落在工作集内的页面需要调入驻留集中，而落在工作集外的页面可从驻留集中换出</p>
<p>若还有空闲物理块，则可再调一个进程到内存</p>
<p>若所有进程的工作集之和超过了可用物理块总数，则操作系统会暂停一个进程，将其页面调出并将物理块分配给其他进程，防止出现抖动现象</p>
</li>
<li><p>问题</p>
<p>过去未必能预示将来，工作集大小和成员会随时间变化</p>
<p>记录工作集变化要求开销太大</p>
<p>Δ 的最优值是未知的</p>
</li>
</ol>
</li>
</ul>
<h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p>将磁盘文件全部或部分内容与进程虚拟地址空间的某个区域建立映射关系，便可以直接访问被映射的文件，而不必执行文件 I/O 操作，也无须对文件内容进行缓存处理</p>
<div align=center><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20231030171841929.png" width="700px"/></dev>

<p>而使用内存映射文件所进行的任何实际交互都是在内存中进行的，并且是以标准的内存地址形式来访问的</p>
<div align=center><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20231030172050630.png" width="700px"/></dev>

<p>磁盘的周期性分页是由操作系统在后台隐蔽实现的，对应用程序而言是完全透明的。系统内存中的所有页面都由虚拟存储器负责管理，虚拟存储器以统一的方式处理所有磁盘 I/O。当进程退出或显式地解除文件映射时，所有被改动的页面都会被写回磁盘文件</p>
<p>多个进程允许并发地映射同一文件，以便允许数据共享</p>
<div align=center><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20231030173017678.png" width="650px"/></dev>

<p>实际上很多时候共享内存就是通过内存映射实现的。进程可以通过共享内存来通信，而共享内存是通过映射相同文件到通信进程的虚拟地址空间实现的，内存映射文件充当通信进程之间的共享内存区域</p>
<p>内存映射文件分为两种类型：</p>
<ol>
<li><p>持久化内存映射文件</p>
<p>持久化文件是与磁盘上的源文件相关联的内存映射文件。当最后一个进程处理完文件或显式地解除文件映射时，所有被改动的页面会被写回磁盘文件。此类内存映射文件适用于处理非常大的源文件</p>
</li>
<li><p>非持久化内存映射文件</p>
<p>非持久化文件是不与磁盘上的文件相关联的内存映射文件。当最后一个进程处理完文件时，数据会丢失，且文件被垃圾回收器回收。此类文件适合创建共享内存，以进行进程内通信(IPC)</p>
</li>
</ol>
<p>内存映射文件总结：</p>
<div align=center><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20231030173407494.png" width="600px"/></dev>

<h3 id="虚拟存储器性能影响因素"><a href="#虚拟存储器性能影响因素" class="headerlink" title="虚拟存储器性能影响因素"></a>虚拟存储器性能影响因素</h3><p>缺页率是影响虚拟存储器性能的主要因素（缺页率高即为抖动）</p>
<p>缺页率又受到页面大小、分配给进程的物理块数即驻留集（取决于工作集）、页面置换算法以及程序的编制方法的影响</p>
<ul>
<li><p>页面较大：缺页率低、减少页表长度；页内碎片增大</p>
<p>页面较小：减少了内存碎片，有利于提高内存利用率；使每个进程要求较多的页面，导致页表过长，占用大量内存</p>
</li>
<li><p>分配给进程的物理块数越多，缺页率就越低，但是当物理块超过某个数目时，再为进程增加物理块对缺页率的改善是不明显的，只是浪费内存空间。只要保证活跃页面在内存中，保持缺页率在一个很低的范围即可</p>
</li>
<li><p>好的页面置换算法可使进程在运行过程中具有较低的缺页率</p>
<p>选择 LRU、CLOCK 等置换算法，将未来有可能访问的页面尽量保存在内存中，从而提高页面的访问速度</p>
</li>
<li><p>编写程序的局部化程度越高，执行时的缺页率就越低</p>
<p>如果存储采用的是按行存储，访问时就要尽量采用相同的访问方式，避免按列访问造成缺页率过高的现象</p>
</li>
</ul>
<p>另外磁盘 I/O 次数对虚拟存储器性能造成影响。脏页攒够一定数量再成批一次换出，不仅可以显著较少磁盘 I/O 的次数，即较少换出脏页的开销，若有进程在这批脏页还未写回磁盘时需要再次访问这些页面时，还可以减少页面从磁盘读入内存的频率，减少页面换进的开销</p>
<h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><h4 id="系统参数"><a href="#系统参数" class="headerlink" title="系统参数"></a>系统参数</h4><p>存储器按字节编址</p>
<p>虚拟地址 14 位，物理地址 12 位</p>
<p>有一个 TLB 与一个 data Cache</p>
<p>页面大小 64B</p>
<p>TLB 四路组相联，共 16 个条目</p>
<p>data Cache 物理寻址、直接映射，行长 4 B，共 16 行（一行一组，可视为 16 组）</p>
<h4 id="地址结构分析"><a href="#地址结构分析" class="headerlink" title="地址结构分析"></a>地址结构分析</h4><p>页面大小 64B = $2^6$B → 页内偏移 6 位 → 虚拟页号 8 位、物理页号 6 位</p>
<p>TLB 四路组相联，共 16 条，即分为 4 = $2^2$ 组 → TLB 组号 2 位、标记位数 = 虚拟页号 8 位 - 组号 2 位 = 6 位</p>
<p>data Cache 行长 4 = $2^2$ B → 行内偏移 2 位</p>
<p>data Cache 虽是直接映射，但这里看作一路组相连映射，16 行即为 16 = $2^4$ 组 → Cache 组号 4 位、标记位数 = 物理地址 12 位 - 行内偏移 2 位 - 组号 4 位 = 6 位</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230709175240191.png" width="800px"/></dev>

<h4 id="数据内容"><a href="#数据内容" class="headerlink" title="数据内容"></a>数据内容</h4><div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230709175801386.png" width="800px"/></dev>

<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230709175959799.png" width="800px"/></dev>

<h4 id="访问过程"><a href="#访问过程" class="headerlink" title="访问过程"></a>访问过程</h4><p>以访问虚拟地址 0x03d4、0x00f1、0x0229 为例</p>
<p>1）首先需要将虚拟地址转化为物理地址，先快表后慢表。虚拟地址化为二进制形式：</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230709180527163.png" width="600px"/></dev>

<p>0x03d4 TLB 组索引为 3，TLB 标记为 03H，查 TLB 发现有匹配项且有效位为 1，得到物理页号 0D，拼接页内地址后得到物理地址 0x354</p>
<p>0x00f1 TLB 组索引为 3，TLB 标记为 00H，TLB 查无此项，再用虚拟页号 03H 去内存中的页表找，匹配的页表项有效位为 1，得到物理页号 02H，拼接页内地址后得到物理地址 0x0b1</p>
<p>0x0229 TLB 组索引为 0，TLB 标记为 02H，TLB 查无此项，再用虚拟页号 08H 去内存中的页表找，匹配的页表项有效位为 0，页面不在内存中，产生缺页中断</p>
<p>2）接下来通过物理地址访问数据，先 Cache 后主存。物理地址的二进制形式为：</p>
<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230709181900925.png" width="600px"/></dev>

<p>0x354 Cache 组号为 5，Cache 标记为 0D，查 Cache 发现有匹配行且有效位为 1，说明要访问的数据在此行中，再根据行内偏移 0 得到要访问的数据内容为 36H</p>
<p>0x0b1 Cache 组号为 C，Cache 标记为 02H，查 Cache 发现有匹配行但有效位为 0，说明要访问的数据不在 Cache 中，只能去主存中取物理页号为 2、页内偏移为 31H 的内容</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zero</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zerooo.top/2024/03/10/OS3_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">https://zerooo.top/2024/03/10/OS3_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zerooo.top" target="_blank">ZERO</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/01/26/DS6_%E5%9B%BE/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">图 | DS</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/article/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zero</div><div class="author-info__description">一些记录</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zero-P" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:zerooop@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">内存管理概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E8%A6%81%E6%B1%82"><span class="toc-number">1.1.</span> <span class="toc-text">基本原理和要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2"><span class="toc-number">1.2.</span> <span class="toc-text">覆盖与交换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%EF%BC%88%E5%90%8C%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">覆盖（同一个进程）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%EF%BC%88%E4%B8%8D%E5%90%8C%E8%BF%9B%E7%A8%8B-%E4%BD%9C%E4%B8%9A%E4%B9%8B%E9%97%B4%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">交换（不同进程&#x2F;作业之间）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">连续分配管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">1.3.1.</span> <span class="toc-text">单一连续分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">1.3.2.</span> <span class="toc-text">固定分区分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D-%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">1.3.3.</span> <span class="toc-text">动态分区分配&#x2F;可变分区分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">非连续分配管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">基本分页存储管理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">基本分段存储管理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.3.</span> <span class="toc-text">段页式管理方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">1.5.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">虚拟内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">请求分页管理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">2.3.</span> <span class="toc-text">页面分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A9%BB%E7%95%99%E9%9B%86%E7%AE%A1%E7%90%86"><span class="toc-number">2.3.1.</span> <span class="toc-text">驻留集管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">2.3.2.</span> <span class="toc-text">调入页面的时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E4%BD%95%E5%A4%84%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2"><span class="toc-number">2.3.3.</span> <span class="toc-text">从何处调入页面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2"><span class="toc-number">2.3.4.</span> <span class="toc-text">如何调入页面</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-OPT"><span class="toc-number">2.4.1.</span> <span class="toc-text">最佳置换算法 OPT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-FIFO"><span class="toc-number">2.4.2.</span> <span class="toc-text">先进先出页面置换算法 FIFO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95-LRU"><span class="toc-number">2.4.3.</span> <span class="toc-text">最近最久未使用算法 LRU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-CLOCK"><span class="toc-number">2.4.4.</span> <span class="toc-text">时钟置换算法 CLOCK</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8%E4%B8%8E%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="toc-number">2.5.</span> <span class="toc-text">抖动与工作集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="toc-number">2.6.</span> <span class="toc-text">内存映射文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0"><span class="toc-number">2.7.</span> <span class="toc-text">虚拟存储器性能影响因素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91"><span class="toc-number">2.8.</span> <span class="toc-text">地址翻译</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0"><span class="toc-number">2.8.1.</span> <span class="toc-text">系统参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-number">2.8.2.</span> <span class="toc-text">地址结构分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%86%85%E5%AE%B9"><span class="toc-number">2.8.3.</span> <span class="toc-text">数据内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B"><span class="toc-number">2.8.4.</span> <span class="toc-text">访问过程</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/10/OS3_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="内存管理 | OS"><img src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="内存管理 | OS"/></a><div class="content"><a class="title" href="/2024/03/10/OS3_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="内存管理 | OS">内存管理 | OS</a><time datetime="2024-03-10T06:39:58.000Z" title="发表于 2024-03-10 14:39:58">2024-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/26/DS6_%E5%9B%BE/" title="图 | DS"><img src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="图 | DS"/></a><div class="content"><a class="title" href="/2024/01/26/DS6_%E5%9B%BE/" title="图 | DS">图 | DS</a><time datetime="2024-01-26T01:31:06.000Z" title="发表于 2024-01-26 09:31:06">2024-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/12/DS5_%E6%A0%91/" title="树 | DS"><img src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="树 | DS"/></a><div class="content"><a class="title" href="/2024/01/12/DS5_%E6%A0%91/" title="树 | DS">树 | DS</a><time datetime="2024-01-12T01:14:08.000Z" title="发表于 2024-01-12 09:14:08">2024-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/11/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" title="常用算法模板"><img src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用算法模板"/></a><div class="content"><a class="title" href="/2024/01/11/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" title="常用算法模板">常用算法模板</a><time datetime="2024-01-11T09:50:08.000Z" title="发表于 2024-01-11 17:50:08">2024-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/11/DS3_%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/" title="栈、队列和数组 | DS"><img src="https://cdn.jsdelivr.net/gh/zero-P/blog-pic@master/img/sunny.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="栈、队列和数组 | DS"/></a><div class="content"><a class="title" href="/2024/01/11/DS3_%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/" title="栈、队列和数组 | DS">栈、队列和数组 | DS</a><time datetime="2024-01-11T01:16:04.000Z" title="发表于 2024-01-11 09:16:04">2024-01-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zero</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script src="/js/catalog.js?1"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>